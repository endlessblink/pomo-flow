<template>
  <div class="calendar-layout">
    <!-- Task Manager Sidebar -->
    <TaskManagerSidebar
      @addTask="handleAddTask"
      @startTimer="handleStartTimer"
      @editTask="handleEditTask"
    />

    <!-- Task Edit Modal -->
    <TaskEditModal
      :is-open="isEditModalOpen"
      :task="selectedTask"
      @close="closeEditModal"
    />

    <!-- Quick Task Create Modal -->
    <QuickTaskCreate
      v-if="dragCreate.quickCreateData.startTime"
      :is-open="dragCreate.showQuickCreateModal.value"
      :start-time="dragCreate.quickCreateData.startTime"
      :end-time="dragCreate.quickCreateData.endTime"
      :duration="dragCreate.quickCreateData.duration"
      @close="dragCreate.showQuickCreateModal.value = false"
      @created="handleTaskCreated"
    />

    <!-- Calendar Main Area -->
    <div class="calendar-main">
      <!-- Calendar Header -->
      <div class="calendar-header">
        <div class="date-navigation">
          <button class="nav-btn" @click="previousDay" title="Previous Day">
            <ChevronLeft :size="16" :stroke-width="1.5" />
          </button>
          <h2 class="current-date">{{ formatCurrentDate }}</h2>
          <button class="nav-btn" @click="nextDay" title="Next Day">
            <ChevronRight :size="16" :stroke-width="1.5" />
          </button>
        </div>
        <div class="header-actions">
          <button class="today-btn" @click="goToToday">
            <Calendar :size="16" :stroke-width="1.5" />
            Today
          </button>

          <!-- Status Filters -->
          <div class="status-filters">
            <button
              class="status-btn"
              :class="{ active: statusFilter === null }"
              @click="statusFilter = null"
              title="All Tasks"
            >
              All
            </button>
            <button
              class="status-btn"
              :class="{ active: statusFilter === 'planned' }"
              @click="statusFilter = 'planned'"
              title="Planned Tasks"
            >
              Planned
            </button>
            <button
              class="status-btn"
              :class="{ active: statusFilter === 'in-progress' }"
              @click="statusFilter = 'in-progress'"
              title="In Progress Tasks"
            >
              Active
            </button>
            <button
              class="status-btn"
              :class="{ active: statusFilter === 'done' }"
              @click="statusFilter = 'done'"
              title="Completed Tasks"
            >
              Done
            </button>
          </div>

          <div class="view-selector">
            <button
              class="view-btn"
              :class="{ active: viewMode === 'day' }"
              @click="viewMode = 'day'"
            >
              Day
            </button>
            <button
              class="view-btn"
              :class="{ active: viewMode === 'week' }"
              @click="viewMode = 'week'"
            >
              Week
            </button>
            <button
              class="view-btn"
              :class="{ active: viewMode === 'month' }"
              @click="viewMode = 'month'"
            >
              Month
            </button>
          </div>
        </div>
      </div>

      <!-- Calendar Grid - Day View -->
      <div v-if="viewMode === 'day'" class="calendar-grid">
        <div class="time-labels">
          <div
            v-for="hour in hours"
            :key="hour"
            class="time-label"
          >
            {{ formatHour(hour) }}
          </div>
        </div>

        <div class="calendar-events-container">
          <!-- Ghost Preview Layer -->
          <div v-if="dragGhost.visible" class="ghost-preview" :style="getGhostStyle()">
            <div class="ghost-content">
              <div class="ghost-title">{{ dragGhost.title }}</div>
              <div class="ghost-duration">{{ dragGhost.duration }}min</div>
            </div>
          </div>

          <!-- Events Layer - pointer-events only on actual events -->
          <div class="events-layer">
            <div
              v-for="event in calendarEvents"
              :key="event.id"
              class="calendar-event"
              :data-duration="event.duration"
              :style="getEventStyle(event)"
              :class="{
                'multi-slot': event.slotSpan > 1,
                'timer-active-event': timerStore.currentTaskId === event.taskId
              }"
              :draggable="dragMode !== 'none'"
              @dragstart="handleEventDragStart($event, event)"
              @dblclick="handleEventDblClick(event)"
              @contextmenu="handleEventContextMenu($event, event)"
            >
              <!-- Top Resize Handle -->
              <div
                class="resize-handle resize-top"
                @mousedown.stop="startResize($event, event, 'top')"
                title="Resize start time"
              ></div>

              <!-- Priority Stripe -->
              <div 
                class="priority-stripe" 
                :class="`priority-${getPriorityClass(event)}`"
                :title="`Priority: ${getPriorityLabel(event)}`"
              ></div>

              <!-- Event Content -->
              <div
                class="event-content"
                @mousedown="handleEventMouseDown($event, event)"
              >
                <div class="event-header">
                  <div class="event-title">{{ event.title }}</div>
                  <div 
                    class="status-indicator"
                    :class="`status-${getTaskStatus(event)}`"
                    @click.stop="cycleTaskStatus($event, event)"
                    :title="`Status: ${getStatusLabel(event)} (click to change)`"
                  >
                    {{ getStatusIcon(getTaskStatus(event)) }}
                  </div>
                </div>
                <div class="event-duration">{{ event.duration }}min</div>
              </div>

              <!-- Bottom Resize Handle -->
              <div
                class="resize-handle resize-bottom"
                @mousedown.stop="startResize($event, event, 'bottom')"
                title="Resize end time"
              ></div>
            </div>
          </div>

          <!-- Time Grid -->
          <div class="time-grid" ref="timeGridRef">
            <div
              v-for="slot in timeSlots"
              :key="slot.id"
              class="time-slot"
              :class="{
                'creating': dragCreate.isSlotInCreateRange(slot)
              }"
              :data-slot-index="slot.slotIndex"
              :data-slot-date="slot.date"
              :data-hour="slot.hour"
              :data-minute="slot.minute"
              @drop="handleDrop($event, slot)"
              @dragover.prevent="handleDragOver($event, slot)"
              @dragenter.prevent="handleDragEnter($event, slot)"
              @dragleave="handleDragLeave"
              @mousedown="dragCreate.handleSlotMouseDown($event, slot)"
            >
            </div>
          </div>

          <!-- Current Time Indicator Layer (Above Events) -->
          <div class="current-time-layer">
            <div
              v-for="slot in timeSlots"
              :key="`time-${slot.id}`"
              class="time-indicator"
              :class="{ 'current-time': isCurrentTimeSlot(slot) }"
            ></div>
          </div>
        </div>
      </div>

      <!-- Week View -->
      <div v-else-if="viewMode === 'week'" class="week-view">
        <!-- Week Header -->
        <div class="week-header">
          <div class="week-time-label"></div>
          <div
            v-for="(day, index) in weekDays"
            :key="index"
            class="week-day-header"
          >
            <div class="week-day-name">{{ day.dayName }}</div>
            <div class="week-day-date">{{ day.date }}</div>
          </div>
        </div>

        <!-- Week Grid Container -->
        <div class="week-grid-container">
          <!-- Time Labels -->
          <div class="week-time-labels">
            <div
              v-for="hour in workingHours"
              :key="hour"
              class="week-time-label"
            >
              {{ formatHour(hour) }}
            </div>
          </div>

          <!-- Week Days Grid -->
          <div class="week-days-grid">
            <!-- Time Grid Background with drop zones -->
            <div class="week-time-grid">
              <div
                v-for="(day, dayIndex) in weekDays"
                :key="`col-${dayIndex}`"
                class="week-day-column"
              >
                <div
                  v-for="(hour, hourIndex) in workingHours"
                  :key="`${dayIndex}-${hour}`"
                  class="week-time-cell"
                  @drop="handleWeekDrop($event, day.dateString, hour)"
                  @dragover.prevent="handleWeekDragOver"
                  @dragenter.prevent
                ></div>
              </div>
            </div>

            <!-- Events Layer -->
            <div class="week-events-layer">
              <div
                v-for="event in weekEvents"
                :key="event.id"
                class="week-event"
                :data-duration="event.duration"
                :style="getWeekEventStyle(event)"
                :class="{
                  'multi-slot': event.slotSpan > 1,
                  'timer-active-event': timerStore.currentTaskId === event.taskId
                }"
                draggable="true"
                @dragstart="handleEventDragStart($event, event)"
              >
                <!-- Top Resize Handle -->
                <div
                  class="resize-handle resize-top"
                  @mousedown.stop="startWeekResize($event, event, 'top')"
                  title="Resize start time"
                ></div>

                <!-- Priority Stripe -->
                <div 
                  class="priority-stripe" 
                  :class="`priority-${getPriorityClass(event)}`"
                  :title="`Priority: ${getPriorityLabel(event)}`"
                ></div>

                <!-- Event Content -->
                <div
                  class="event-content"
                  @mousedown="handleWeekEventMouseDown($event, event)"
                  @dblclick="handleEventDblClick(event)"
                  @contextmenu="handleEventContextMenu($event, event)"
                >
                  <div class="event-header">
                    <div class="event-title">{{ event.title }}</div>
                    <div 
                      class="status-indicator"
                      :class="`status-${getTaskStatus(event)}`"
                      @click.stop="cycleTaskStatus($event, event)"
                      :title="`Status: ${getStatusLabel(event)} (click to change)`"
                    >
                      {{ getStatusIcon(getTaskStatus(event)) }}
                    </div>
                  </div>
                  <div class="event-duration">{{ event.duration }}min</div>
                </div>

                <!-- Bottom Resize Handle -->
                <div
                  class="resize-handle resize-bottom"
                  @mousedown.stop="startWeekResize($event, event, 'bottom')"
                  title="Resize end time"
                ></div>
              </div>
            </div>

            <!-- Current Time Indicator Layer (Above Events) -->
            <div class="week-current-time-layer">
              <div
                v-for="(day, dayIndex) in weekDays"
                :key="`time-${dayIndex}`"
                class="week-day-time-column"
              >
                <div
                  v-for="hour in workingHours"
                  :key="`time-${dayIndex}-${hour}`"
                  class="week-time-indicator"
                  :class="{ 'current-time': isCurrentWeekTimeCell(day.dateString, hour) }"
                ></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Month View -->
      <div v-else-if="viewMode === 'month'" class="month-view">
        <!-- Month Grid -->
        <div class="month-grid">
          <div
            v-for="day in monthDays"
            :key="day.dateString"
            class="month-day-cell"
            :class="{
              'other-month': !day.isCurrentMonth,
              'today': day.isToday
            }"
            @drop="handleMonthDrop($event, day.dateString)"
            @dragover.prevent
            @dragenter.prevent
            @click="handleMonthDayClick(day.dateString)"
          >
            <div class="day-number">{{ day.dayNumber }}</div>

            <div class="day-events">
              <div
                v-for="event in day.events"
                :key="event.id"
                class="month-event"
                :class="{ 'timer-active-event': timerStore.currentTaskId === event.taskId }"
                :style="{ backgroundColor: event.color }"
                draggable="true"
                @dragstart="handleMonthDragStart($event, event)"
                @dblclick.stop="handleEventDblClick(event)"
                @contextmenu.stop="handleEventContextMenu($event, event)"
                @click.stop
              >
                <div 
                  class="priority-stripe" 
                  :class="`priority-${getPriorityClass(event)}`"
                  :title="`Priority: ${getPriorityLabel(event)}`"
                ></div>
                <div 
                  class="priority-stripe" 
                  :class="`priority-${getPriorityClass(event)}`"
                  :title="`Priority: ${getPriorityLabel(event)}`"
                ></div>
                <span class="event-time">{{ formatEventTime(event) }}</span>
                <span 
                  class="event-title-short"
                  @click.stop="cycleTaskStatus($event, event)"
                  :title="`Status: ${getStatusLabel(event)} (click to change)`"
                >
                  {{ getStatusIcon(getTaskStatus(event)) }} {{ event.title }}
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, nextTick } from 'vue'
import { useTaskStore, getTaskInstances, type Task } from '@/stores/tasks'
import { useTimerStore } from '@/stores/timer'
import { useCalendarDragCreate } from '@/composables/useCalendarDragCreate'
import { useDragAndDrop, type DragData } from '@/composables/useDragAndDrop'
import TaskManagerSidebar from '@/components/TaskManagerSidebar.vue'
import TaskEditModal from '@/components/TaskEditModal.vue'
import QuickTaskCreate from '@/components/QuickTaskCreate.vue'
import { ChevronLeft, ChevronRight, Calendar, Flag, Clock, Inbox } from 'lucide-vue-next'

interface CalendarEvent {
  id: string // Now represents instanceId
  taskId: string
  instanceId: string
  title: string
  startTime: Date
  endTime: Date
  duration: number
  startSlot: number
  slotSpan: number
  color: string
  column: number
  totalColumns: number
}

interface TimeSlot {
  id: string
  hour: number
  minute: number
  slotIndex: number
  date: string
}

const taskStore = useTaskStore()
const timerStore = useTimerStore()

// Use drag-to-create composable
const dragCreate = useCalendarDragCreate()

// Use drag-and-drop composable for global drag state
const { startDrag, endDrag } = useDragAndDrop()

const currentDate = ref(new Date())
const viewMode = ref<'day' | 'week' | 'month'>('day')
const statusFilter = ref<'planned' | 'in-progress' | 'done' | null>(null)
const timeGridRef = ref<HTMLElement | null>(null)

// Reactive current time for time indicator
const currentTime = ref(new Date())
let timeUpdateInterval: NodeJS.Timeout | null = null

// Task Edit Modal state
const isEditModalOpen = ref(false)
const selectedTask = ref<Task | null>(null)

// Drag ghost state (for sidebar drag-and-drop)
const dragGhost = ref({
  visible: false,
  title: '',
  duration: 30,
  slotIndex: 0
})

// Scroll synchronization
let calendarEventsContainer: HTMLElement | null = null
let timeLabelsContainer: HTMLElement | null = null
let scrollHandler: ((event: Event) => void) | null = null

const setupScrollSync = () => {
  // Use nextTick to ensure DOM is ready
  nextTick(() => {
    calendarEventsContainer = document.querySelector('.calendar-events-container') as HTMLElement
    timeLabelsContainer = document.querySelector('.time-labels') as HTMLElement

    if (calendarEventsContainer && timeLabelsContainer) {
      scrollHandler = () => {
        if (timeLabelsContainer && calendarEventsContainer) {
          timeLabelsContainer.scrollTop = calendarEventsContainer.scrollTop
        }
      }

      calendarEventsContainer.addEventListener('scroll', scrollHandler, { passive: true })
    }
  })
}

const cleanupScrollSync = () => {
  if (calendarEventsContainer && scrollHandler) {
    calendarEventsContainer.removeEventListener('scroll', scrollHandler)
  }
}

onMounted(() => {
  setupScrollSync()
  
  // Update current time every 30 seconds for smoother time indicator movement
  currentTime.value = new Date()
  timeUpdateInterval = setInterval(() => {
    currentTime.value = new Date()
  }, 30000) // Update every 30 seconds
})

onUnmounted(() => {
  cleanupScrollSync()
  
  // Clean up time update interval
  if (timeUpdateInterval) {
    clearInterval(timeUpdateInterval)
    timeUpdateInterval = null
  }
})

const formatCurrentDate = computed(() => {
  if (viewMode.value === 'week') {
    const weekStart = getWeekStart(currentDate.value)
    const weekEnd = new Date(weekStart)
    weekEnd.setDate(weekEnd.getDate() + 6)

    const startMonth = weekStart.toLocaleDateString('en-US', { month: 'short' })
    const endMonth = weekEnd.toLocaleDateString('en-US', { month: 'short' })
    const year = weekStart.getFullYear()

    if (startMonth === endMonth) {
      return `${startMonth} ${weekStart.getDate()} - ${weekEnd.getDate()}, ${year}`
    } else {
      return `${startMonth} ${weekStart.getDate()} - ${endMonth} ${weekEnd.getDate()}, ${year}`
    }
  }

  if (viewMode.value === 'month') {
    return currentDate.value.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long'
    })
  }

  return currentDate.value.toLocaleDateString('en-US', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  })
})

const hours = Array.from({ length: 24 }, (_, i) => i)
const workingHours = Array.from({ length: 17 }, (_, i) => i + 6) // 6 AM to 10 PM

// Helper function to get week start (Monday)
const getWeekStart = (date: Date) => {
  const d = new Date(date)
  const day = d.getDay()
  const diff = d.getDate() - day + (day === 0 ? -6 : 1) // Adjust when day is Sunday
  d.setDate(diff)
  d.setHours(0, 0, 0, 0)
  return d
}

// Helper function to get date string in local timezone
const getDateString = (date: Date) => {
  const year = date.getFullYear()
  const month = (date.getMonth() + 1).toString().padStart(2, '0')
  const day = date.getDate().toString().padStart(2, '0')
  return `${year}-${month}-${day}`
}

// Computed property for week days
const weekDays = computed(() => {
  const weekStart = getWeekStart(currentDate.value)
  const days = []

  for (let i = 0; i < 7; i++) {
    const date = new Date(weekStart)
    date.setDate(weekStart.getDate() + i)

    days.push({
      dayName: date.toLocaleDateString('en-US', { weekday: 'short' }),
      date: date.getDate(),
      dateString: getDateString(date),
      fullDate: date
    })
  }

  return days
})

// Computed property for week events
const weekEvents = computed(() => {
  const events: (CalendarEvent & { dayIndex: number })[] = []

  weekDays.value.forEach((day, dayIndex) => {
    taskStore.filteredTasks
      .filter(task => {
        // Apply status filter if set
        if (statusFilter.value === null) return true
        return task.status === statusFilter.value
      })
      .forEach(task => {
      const instances = getTaskInstances(task)

      instances
        .filter(instance => instance.scheduledDate === day.dateString)
        .forEach(instance => {
          const [hour, minute] = instance.scheduledTime.split(':').map(Number)
          const duration = instance.duration || task.estimatedDuration || 30

          // Only show if within working hours
          if (hour >= 6 && hour < 23) {
            const startTime = new Date(`${instance.scheduledDate}T${instance.scheduledTime}`)
            const endTime = new Date(startTime.getTime() + duration * 60000)

            events.push({
              id: instance.id,
              taskId: task.id,
              instanceId: instance.id,
              title: task.title,
              startTime,
              endTime,
              duration,
              startSlot: (hour - 6) * 2 + (minute === 30 ? 1 : 0),
              slotSpan: Math.ceil(duration / 30),
              color: getPriorityColor(task.priority),
              column: 0,
              totalColumns: 1,
              dayIndex
            })
          }
        })
    })
  })

  return events
})

// Get style for week event
const getWeekEventStyle = (event: CalendarEvent & { dayIndex: number }) => {
  const HALF_HOUR_HEIGHT = 30
  const dayColumnWidth = 100 / 7

  return {
    position: 'absolute',
    top: `${event.startSlot * HALF_HOUR_HEIGHT}px`,
    height: `${event.slotSpan * HALF_HOUR_HEIGHT}px`,
    left: `${event.dayIndex * dayColumnWidth}%`,
    width: `${dayColumnWidth}%`
  }
}

// Computed property for month days
const monthDays = computed(() => {
  const year = currentDate.value.getFullYear()
  const month = currentDate.value.getMonth()

  const firstDay = new Date(year, month, 1)
  const lastDay = new Date(year, month + 1, 0)
  const startDate = new Date(firstDay)

  // Adjust to start on Monday
  const dayOfWeek = firstDay.getDay()
  startDate.setDate(startDate.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1))

  const days = []
  const today = getDateString(new Date())

  for (let i = 0; i < 42; i++) { // 6 weeks × 7 days
    const date = new Date(startDate)
    date.setDate(date.getDate() + i)

    const dateString = getDateString(date)

    // Get events for this day
    const dayEvents: CalendarEvent[] = []
    taskStore.filteredTasks.forEach(task => {
      const instances = getTaskInstances(task)
      instances
        .filter(instance => instance.scheduledDate === dateString)
        .forEach(instance => {
          const [hour, minute] = instance.scheduledTime.split(':').map(Number)
          const duration = instance.duration || task.estimatedDuration || 30

          dayEvents.push({
            id: instance.id,
            taskId: task.id,
            instanceId: instance.id,
            title: task.title,
            startTime: new Date(`${instance.scheduledDate}T${instance.scheduledTime}`),
            endTime: new Date(new Date(`${instance.scheduledDate}T${instance.scheduledTime}`).getTime() + duration * 60000),
            duration,
            startSlot: 0,
            slotSpan: 0,
            color: getPriorityColor(task.priority),
            column: 0,
            totalColumns: 1
          })
        })
    })

    days.push({
      dateString,
      dayNumber: date.getDate(),
      isCurrentMonth: date.getMonth() === month,
      isToday: dateString === today,
      events: dayEvents
    })
  }

  return days
})

// Format event time for month view
const formatEventTime = (event: CalendarEvent) => {
  return event.startTime.toLocaleTimeString('en-US', {
    hour: 'numeric',
    minute: '2-digit',
    hour12: true
  })
}

const timeSlots = computed(() => {
  const slots: TimeSlot[] = []
  const dateStr = currentDate.value.toISOString().split('T')[0]
  let slotIndex = 0

  hours.forEach(hour => {
    [0, 30].forEach(minute => {
      slots.push({
        id: `${dateStr}-${hour}-${minute}`,
        hour,
        minute,
        slotIndex,
        date: dateStr
      })
      slotIndex++
    })
  })

  return slots
})

const calendarEvents = computed(() => {
  const dateStr = currentDate.value.toISOString().split('T')[0]

  const events: CalendarEvent[] = []

  // Iterate through all tasks and their instances
  taskStore.filteredTasks
    .filter(task => {
      // Apply status filter if set
      if (statusFilter.value === null) return true
      return task.status === statusFilter.value
    })
    .forEach(task => {
    const instances = getTaskInstances(task)

    // Filter instances for current date
    instances
      .filter(instance => instance.scheduledDate === dateStr)
      .forEach(instance => {
        const [hour, minute] = instance.scheduledTime.split(':').map(Number)
        const startTime = new Date(`${instance.scheduledDate}T${instance.scheduledTime}`)
        const duration = instance.duration || task.estimatedDuration || 30
        const endTime = new Date(startTime.getTime() + duration * 60000)

        const startSlot = hour * 2 + (minute === 30 ? 1 : 0)
        const slotSpan = Math.ceil(duration / 30)

        events.push({
          id: instance.id,
          taskId: task.id,
          instanceId: instance.id,
          title: task.title,
          startTime,
          endTime,
          duration,
          startSlot,
          slotSpan,
          color: getPriorityColor(task.priority),
          column: 0,
          totalColumns: 1
        })
      })
  })

  return calculateOverlappingPositions(events)
})

const calculateOverlappingPositions = (events: CalendarEvent[]) => {
  if (events.length === 0) return events

  const sorted = [...events].sort((a, b) => a.startSlot - b.startSlot)

  // Find groups of overlapping events
  const groups: CalendarEvent[][] = []
  let currentGroup: CalendarEvent[] = []

  sorted.forEach((event, index) => {
    if (index === 0) {
      currentGroup.push(event)
      return
    }

    // Check if this event overlaps with any event in current group
    const overlapsWithGroup = currentGroup.some(existing =>
      event.startSlot < existing.startSlot + existing.slotSpan &&
      event.startSlot + event.slotSpan > existing.startSlot
    )

    if (overlapsWithGroup) {
      currentGroup.push(event)
    } else {
      // Start new group
      groups.push(currentGroup)
      currentGroup = [event]
    }
  })

  // Don't forget the last group
  if (currentGroup.length > 0) {
    groups.push(currentGroup)
  }

  // Assign columns within each group independently
  groups.forEach(group => {
    const columns: CalendarEvent[][] = []

    group.forEach(event => {
      let placed = false

      for (let i = 0; i < columns.length; i++) {
        const column = columns[i]
        const hasCollision = column.some(existing =>
          event.startSlot < existing.startSlot + existing.slotSpan &&
          event.startSlot + event.slotSpan > existing.startSlot
        )

        if (!hasCollision) {
          column.push(event)
          event.column = i
          placed = true
          break
        }
      }

      if (!placed) {
        columns.push([event])
        event.column = columns.length - 1
      }
    })

    // Set totalColumns for this group only
    const totalColumns = columns.length
    group.forEach(event => {
      event.totalColumns = totalColumns
    })
  })

  return sorted
}

const formatHour = (hour: number) => {
  const period = hour >= 12 ? 'PM' : 'AM'
  const displayHour = hour > 12 ? hour - 12 : hour === 0 ? 12 : hour
  return `${displayHour} ${period}`
}

const getPriorityColor = (priority: string) => {
  switch (priority) {
    case 'high': return 'var(--priority-high-bg)'
    case 'low': return 'var(--priority-low-bg)'
    default: return 'var(--priority-medium-bg)'
  }
}

const isCurrentTimeSlot = (slot: TimeSlot) => {
  const now = currentTime.value
  const slotDate = new Date(`${slot.date}T${slot.hour.toString().padStart(2, '0')}:${slot.minute.toString().padStart(2, '0')}`)
  const slotEnd = new Date(slotDate.getTime() + 30 * 60000)

  return now >= slotDate && now < slotEnd &&
         slot.date === now.toISOString().split('T')[0]
}

const isCurrentWeekTimeCell = (dateString: string, hour: number) => {
  const now = currentTime.value
  const currentHour = now.getHours()
  const todayString = getDateString(now)
  
  return dateString === todayString && hour === currentHour
}

const getEventStyle = (event: CalendarEvent) => {
  const slotHeight = 30

  const widthPercentage = 100 / event.totalColumns
  const leftPercentage = widthPercentage * event.column

  return {
    top: `${event.startSlot * slotHeight}px`,
    height: `${event.slotSpan * slotHeight}px`,
    left: `${leftPercentage}%`,
    width: `${widthPercentage}%`
  }
}

const getGhostStyle = () => {
  const slotHeight = 30
  const slotSpan = Math.ceil(dragGhost.value.duration / 30)

  return {
    top: `${dragGhost.value.slotIndex * slotHeight}px`,
    height: `${slotSpan * slotHeight}px`,
    left: '0',
    width: '100%'
  }
}

const previousDay = () => {
  const date = new Date(currentDate.value)
  date.setDate(date.getDate() - 1)
  currentDate.value = date
}

const nextDay = () => {
  const date = new Date(currentDate.value)
  date.setDate(date.getDate() + 1)
  currentDate.value = date
}

const goToToday = () => {
  currentDate.value = new Date()
}

const handleAddTask = () => {
  const now = new Date()
  const dateStr = currentDate.value.toISOString().split('T')[0]
  const timeStr = `${now.getHours().toString().padStart(2, '0')}:00`

  taskStore.createTask({
    title: 'Test Task',
    scheduledDate: dateStr,
    scheduledTime: timeStr,
    estimatedDuration: 60
  })
}

const handleStartTimer = (taskId: string) => {
  timerStore.startTimer(taskId)
}

const handleEditTask = (taskId: string) => {
  const task = taskStore.tasks.find(t => t.id === taskId)
  if (task) {
    selectedTask.value = task
    isEditModalOpen.value = true
  }
}

const closeEditModal = () => {
  isEditModalOpen.value = false
  selectedTask.value = null
}

const handleTaskCreated = (task: Task) => {
  console.log('Task created:', task)
  dragCreate.showQuickCreateModal.value = false
  dragCreate.resetCreateDrag()
}

const handleDragEnter = (event: DragEvent, slot: TimeSlot) => {
  event.preventDefault()

  const data = event.dataTransfer?.getData('application/json')
  if (!data) return

  try {
    const { title, taskId } = JSON.parse(data)
    const task = taskStore.tasks.find(t => t.id === taskId)

    dragGhost.value = {
      visible: true,
      title: title || 'New Task',
      duration: task?.estimatedDuration || 30,
      slotIndex: slot.slotIndex
    }
  } catch (e) {
    // Invalid data, ignore
  }
}

const handleDragOver = (event: DragEvent, slot: TimeSlot) => {
  event.preventDefault()
  event.dataTransfer!.dropEffect = 'move'

  // Update ghost position as user drags over slots
  if (dragGhost.value.visible) {
    dragGhost.value.slotIndex = slot.slotIndex
  }
}

const handleDragLeave = () => {
  // Keep ghost visible, don't hide on leave
  // Only hide on drop or drag end
}

const handleDrop = (event: DragEvent, slot: TimeSlot) => {
  event.preventDefault()

  const data = event.dataTransfer?.getData('application/json')
  if (!data) return

  const { taskId } = JSON.parse(data)
  const timeStr = `${slot.hour.toString().padStart(2, '0')}:${slot.minute.toString().padStart(2, '0')}`

  // Create new task instance - enables task reuse
  taskStore.createTaskInstance(taskId, {
    scheduledDate: slot.date,
    scheduledTime: timeStr
  })

  // Hide ghost after drop
  dragGhost.value.visible = false
}

const startResize = (event: MouseEvent, calendarEvent: CalendarEvent, direction: 'top' | 'bottom') => {
  event.preventDefault()

  const startY = event.clientY
  const SLOT_HEIGHT = 30
  const originalStartSlot = calendarEvent.startSlot
  const originalDuration = calendarEvent.duration

  const handleMouseMove = (e: MouseEvent) => {
    const deltaY = e.clientY - startY
    const deltaSlots = Math.round(deltaY / SLOT_HEIGHT)

    let newDuration = originalDuration
    let newStartSlot = originalStartSlot

    if (direction === 'bottom') {
      newDuration = Math.max(30, originalDuration + (deltaSlots * 30))
    } else {
      const endSlot = originalStartSlot + Math.ceil(originalDuration / 30)
      newStartSlot = Math.max(0, originalStartSlot + deltaSlots)
      newDuration = Math.max(30, (endSlot - newStartSlot) * 30)
    }

    // Update specific instance, not the task template
    if (direction === 'bottom') {
      // Bottom resize: just update duration
      taskStore.updateTaskInstance(calendarEvent.taskId, calendarEvent.instanceId, {
        duration: newDuration
      })
    } else {
      // Top resize: update both start time and duration
      const [currentHour, currentMinute] = calendarEvent.startTime.toTimeString().slice(0, 5).split(':').map(Number)
      const currentEndTime = currentHour * 60 + currentMinute + originalDuration
      const newStartTime = currentEndTime - newDuration
      const newHour = Math.floor(newStartTime / 60)
      const newMinute = newStartTime % 60

      if (newStartTime >= 0) {
        taskStore.updateTaskInstance(calendarEvent.taskId, calendarEvent.instanceId, {
          scheduledTime: `${newHour.toString().padStart(2, '0')}:${newMinute.toString().padStart(2, '0')}`,
          duration: newDuration
        })
      }
    }
  }

  const handleMouseUp = () => {
    document.removeEventListener('mousemove', handleMouseMove)
    document.removeEventListener('mouseup', handleMouseUp)
  }

  document.addEventListener('mousemove', handleMouseMove)
  document.addEventListener('mouseup', handleMouseUp)
}

const startEventDrag = (event: MouseEvent, calendarEvent: CalendarEvent) => {
  event.preventDefault()

  const container = document.querySelector('.calendar-events-container') as HTMLElement
  if (!container) return

  const rect = container.getBoundingClientRect()
  const SLOT_HEIGHT = 30
  const eventElement = (event.target as HTMLElement).closest('.calendar-event') as HTMLElement
  if (!eventElement) return

  const eventRect = eventElement.getBoundingClientRect()
  const clickOffsetY = event.clientY - eventRect.top

  // Detect Alt key for duplicate mode
  const isDuplicateMode = event.altKey
  let duplicateInstanceId: string | null = null

  // Store initial state
  const initialSlot = calendarEvent.startSlot
  let lastUpdatedSlot = initialSlot

  const handleMouseMove = (e: MouseEvent) => {
    requestAnimationFrame(() => {
      const containerScrollTop = container.scrollTop || 0
      const targetY = e.clientY - rect.top + containerScrollTop - clickOffsetY
      const targetSlot = Math.max(0, Math.min(47, Math.floor(targetY / SLOT_HEIGHT)))

      // Only update if slot actually changed to prevent jittery updates
      if (targetSlot !== lastUpdatedSlot) {
        lastUpdatedSlot = targetSlot

        const newHour = Math.floor((targetSlot * 30) / 60)
        const newMinute = (targetSlot * 30) % 60
        const newTime = `${newHour.toString().padStart(2, '0')}:${newMinute.toString().padStart(2, '0')}`

        if (isDuplicateMode) {
          // Shift+Drag: Create duplicate on first move, then update it
          if (!duplicateInstanceId) {
            const newInstance = taskStore.createTaskInstance(calendarEvent.taskId, {
              scheduledDate: currentDate.value.toISOString().split('T')[0],
              scheduledTime: newTime,
              duration: calendarEvent.duration
            })
            if (newInstance) {
              duplicateInstanceId = newInstance.id
            }
          } else {
            // Update the duplicate
            taskStore.updateTaskInstance(calendarEvent.taskId, duplicateInstanceId, {
              scheduledDate: currentDate.value.toISOString().split('T')[0],
              scheduledTime: newTime
            })
          }
        } else {
          // Normal drag: Move the original instance
          taskStore.updateTaskInstance(calendarEvent.taskId, calendarEvent.instanceId, {
            scheduledDate: currentDate.value.toISOString().split('T')[0],
            scheduledTime: newTime
          })
        }
      }
    })
  }

  const handleMouseUp = () => {
    document.removeEventListener('mousemove', handleMouseMove)
    document.removeEventListener('mouseup', handleMouseUp)
  }

  document.addEventListener('mousemove', handleMouseMove)
  document.addEventListener('mouseup', handleMouseUp)
}

const dragMode = ref<'none' | 'shift'>('none')

const handleEventDragStart = (event: DragEvent, calendarEvent: CalendarEvent) => {
  // Only allow HTML5 drag when Shift is held
  if (!event.shiftKey) {
    event.preventDefault()
    return
  }

  if (event.dataTransfer) {
    event.dataTransfer.setData('application/json', JSON.stringify({
      taskId: calendarEvent.taskId,
      instanceId: calendarEvent.instanceId
    }))
    event.dataTransfer.effectAllowed = 'move'
  }
}

const handleEventMouseDown = (event: MouseEvent, calendarEvent: CalendarEvent) => {
  if (event.shiftKey) {
    // Shift+drag: Enable HTML5 drag for sidebar unscheduling
    dragMode.value = 'shift'
    return
  }

  // Alt+drag: Duplicate mode
  // Normal drag: Reposition mode
  event.preventDefault()
  event.stopPropagation()
  startEventDrag(event, calendarEvent)
}

const handleEventDblClick = (calendarEvent: CalendarEvent) => {
  handleEditTask(calendarEvent.taskId)
}

const handleEventContextMenu = (mouseEvent: MouseEvent, calendarEvent: CalendarEvent) => {
  mouseEvent.preventDefault()
  mouseEvent.stopPropagation()

  // Get the task from the store
  const task = taskStore.tasks.find(t => t.id === calendarEvent.taskId)
  if (!task) return

  // Dispatch custom event for App.vue to handle
  window.dispatchEvent(new CustomEvent('task-context-menu', {
    detail: { event: mouseEvent, task }
  }))
}

const handleWeekEventMouseDown = (event: MouseEvent, calendarEvent: CalendarEvent & { dayIndex: number }) => {
  if (event.shiftKey) {
    // Shift+drag: Enable HTML5 drag for sidebar unscheduling
    dragMode.value = 'shift'
    return
  }

  // Alt+drag: Duplicate mode
  // Normal drag: Reposition mode
  event.preventDefault()
  event.stopPropagation()
  startWeekDrag(event, calendarEvent)
}

// Week view drag functionality - Following Day view pattern EXACTLY
const startWeekDrag = (event: MouseEvent, calendarEvent: CalendarEvent & { dayIndex: number }) => {
  event.preventDefault()
  event.stopPropagation()

  const weekDaysGrid = document.querySelector('.week-days-grid') as HTMLElement
  if (!weekDaysGrid) return

  const gridRect = weekDaysGrid.getBoundingClientRect()
  const dayColumnWidth = gridRect.width / 7
  const HALF_HOUR_HEIGHT = 30
  const WORKING_HOURS_OFFSET = 6 // 6 AM start

  const eventRect = (event.target as HTMLElement).closest('.week-event')?.getBoundingClientRect()
  if (!eventRect) return

  const clickOffsetY = event.clientY - eventRect.top

  // Detect Alt key for duplicate mode
  const isDuplicateMode = event.altKey
  let duplicateInstanceId: string | null = null

  // Track last updated position to prevent unnecessary updates (Day view pattern)
  let lastUpdatedDayIndex = calendarEvent.dayIndex
  let lastUpdatedSlot = calendarEvent.startSlot

  const handleMouseMove = (e: MouseEvent) => {
    requestAnimationFrame(() => {
      const scrollTop = weekDaysGrid.scrollTop || 0

      // Calculate day column
      const relativeX = e.clientX - gridRect.left
      const newDayIndex = Math.max(0, Math.min(6, Math.floor(relativeX / dayColumnWidth)))

      // Calculate time slot
      const mouseYInGrid = e.clientY - gridRect.top + scrollTop
      const eventTopInGrid = mouseYInGrid - clickOffsetY
      const slotFromTop = Math.max(0, Math.min(33, Math.round(eventTopInGrid / HALF_HOUR_HEIGHT)))

      // Only update if position changed (Day view pattern - prevents unnecessary updates)
      if (slotFromTop !== lastUpdatedSlot || newDayIndex !== lastUpdatedDayIndex) {
        lastUpdatedSlot = slotFromTop
        lastUpdatedDayIndex = newDayIndex

        const newHour = Math.floor(slotFromTop / 2) + WORKING_HOURS_OFFSET
        const newMinute = (slotFromTop % 2) * 30
        const newDate = weekDays.value[newDayIndex].dateString
        const newTime = `${newHour.toString().padStart(2, '0')}:${newMinute.toString().padStart(2, '0')}`

        if (isDuplicateMode) {
          // Shift+Drag: Create duplicate on first move, then update it
          if (!duplicateInstanceId) {
            const newInstance = taskStore.createTaskInstance(calendarEvent.taskId, {
              scheduledDate: newDate,
              scheduledTime: newTime,
              duration: calendarEvent.duration
            })
            if (newInstance) {
              duplicateInstanceId = newInstance.id
            }
          } else {
            // Update the duplicate
            taskStore.updateTaskInstance(calendarEvent.taskId, duplicateInstanceId, {
              scheduledDate: newDate,
              scheduledTime: newTime
            })
          }
        } else {
          // Normal drag: Move the original instance
          taskStore.updateTaskInstance(calendarEvent.taskId, calendarEvent.instanceId, {
            scheduledDate: newDate,
            scheduledTime: newTime
          })
        }
      }
    })
  }

  const handleMouseUp = () => {
    document.removeEventListener('mousemove', handleMouseMove)
    document.removeEventListener('mouseup', handleMouseUp)
  }

  document.addEventListener('mousemove', handleMouseMove)
  document.addEventListener('mouseup', handleMouseUp)
}

// Week view resize functionality
const startWeekResize = (event: MouseEvent, calendarEvent: CalendarEvent & { dayIndex: number }, direction: 'top' | 'bottom') => {
  event.preventDefault()

  const startY = event.clientY
  const HALF_HOUR_HEIGHT = 30
  const WORKING_HOURS_OFFSET = 6
  const originalStartSlot = calendarEvent.startSlot
  const originalDuration = calendarEvent.duration

  const handleMouseMove = (e: MouseEvent) => {
    const deltaY = e.clientY - startY
    const deltaSlots = Math.round(deltaY / HALF_HOUR_HEIGHT)

    let newDuration = originalDuration
    let newStartSlot = originalStartSlot

    if (direction === 'bottom') {
      // Bottom resize: only change duration
      newDuration = Math.max(30, originalDuration + (deltaSlots * 30))
    } else {
      // Top resize: change both start time and duration
      const endSlot = originalStartSlot + Math.ceil(originalDuration / 30)
      newStartSlot = Math.max(0, Math.min(33, originalStartSlot + deltaSlots))
      newDuration = Math.max(30, (endSlot - newStartSlot) * 30)
    }

    // Update specific instance
    if (direction === 'bottom') {
      taskStore.updateTaskInstance(calendarEvent.taskId, calendarEvent.instanceId, {
        duration: newDuration
      })
    } else {
      // Top resize: calculate new start time
      const newHour = Math.floor(newStartSlot / 2) + WORKING_HOURS_OFFSET
      const newMinute = (newStartSlot % 2) * 30

      if (newHour >= WORKING_HOURS_OFFSET && newHour < 23) {
        taskStore.updateTaskInstance(calendarEvent.taskId, calendarEvent.instanceId, {
          scheduledTime: `${newHour.toString().padStart(2, '0')}:${newMinute.toString().padStart(2, '0')}`,
          duration: newDuration
        })
      }
    }
  }

  const handleMouseUp = () => {
    document.removeEventListener('mousemove', handleMouseMove)
    document.removeEventListener('mouseup', handleMouseUp)
  }

  document.addEventListener('mousemove', handleMouseMove)
  document.addEventListener('mouseup', handleMouseUp)
}

// Week view drop handlers (for sidebar drag-to-calendar)
const handleWeekDragOver = (event: DragEvent) => {
  event.preventDefault()
  event.dataTransfer!.dropEffect = 'move'
}

const handleWeekDrop = (event: DragEvent, dateString: string, hour: number) => {
  event.preventDefault()

  const data = event.dataTransfer?.getData('application/json')
  if (!data) return

  const { taskId } = JSON.parse(data)
  const timeStr = `${hour.toString().padStart(2, '0')}:00`

  // Create new task instance for the week view
  taskStore.createTaskInstance(taskId, {
    scheduledDate: dateString,
    scheduledTime: timeStr
  })
}

// Month view drag handlers
const handleMonthDragStart = (event: DragEvent, calendarEvent: CalendarEvent) => {
  event.dataTransfer?.setData('application/json', JSON.stringify({
    taskId: calendarEvent.taskId,
    instanceId: calendarEvent.instanceId
  }))
}

const handleMonthDrop = (event: DragEvent, targetDate: string) => {
  event.preventDefault()

  const data = event.dataTransfer?.getData('application/json')
  if (!data) return

  const { taskId, instanceId } = JSON.parse(data)

  if (instanceId) {
    // Moving existing event - update its date, keep time
    taskStore.updateTaskInstance(taskId, instanceId, {
      scheduledDate: targetDate
    })
  } else {
    // Creating new instance from sidebar
    taskStore.createTaskInstance(taskId, {
      scheduledDate: targetDate,
      scheduledTime: '09:00' // Default to 9 AM
    })
  }
}

const handleMonthDayClick = (dateString: string) => {
  // Switch to Day view for the clicked date
  const [year, month, day] = dateString.split('-').map(Number)
  currentDate.value = new Date(year, month - 1, day)
  viewMode.value = 'day'
}

// Priority helper functions
const getPriorityClass = (event: CalendarEvent) => {
  const task = taskStore.tasks.find(t => t.id === event.taskId)
  return task?.priority || 'medium'
}

const getPriorityLabel = (event: CalendarEvent) => {
  const task = taskStore.tasks.find(t => t.id === event.taskId)
  const priority = task?.priority || 'medium'
  return priority.charAt(0).toUpperCase() + priority.slice(1).replace('_', ' ')
}

// Status helper functions
const getTaskStatus = (event: CalendarEvent) => {
  const task = taskStore.tasks.find(t => t.id === event.taskId)
  return task?.status || 'planned'
}

const getStatusLabel = (event: CalendarEvent) => {
  const status = getTaskStatus(event)
  return status.charAt(0).toUpperCase() + status.slice(1).replace('_', ' ')
}

const getStatusIcon = (status: string) => {
  const icons = {
    'planned': '○',
    'in_progress': '▶',
    'done': '✓',
    'backlog': '⏸',
    'on_hold': '⏸'
  }
  return icons[status as keyof typeof icons] || '○'
}

const cycleTaskStatus = (event: MouseEvent, calendarEvent: CalendarEvent) => {
  event.preventDefault()
  event.stopPropagation()
  
  const task = taskStore.tasks.find(t => t.id === calendarEvent.taskId)
  if (!task) return
  
  const statusCycle: Task['status'][] = ['planned', 'in_progress', 'done', 'backlog', 'on_hold']
  const currentIndex = statusCycle.indexOf(task.status)
  const nextIndex = (currentIndex + 1) % statusCycle.length
  const nextStatus = statusCycle[nextIndex]
  
  taskStore.moveTask(task.id, nextStatus)
}
</script>

<style scoped>
.calendar-layout {
  display: flex;
  height: 100vh;
  background: var(--surface-primary);
  overflow: visible;
}

.calendar-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow-y: auto;
}

.calendar-header {
  position: sticky;
  top: 0;
  z-index: 200; /* Above all calendar content and events */
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-6) var(--space-8);
  /* Solid background to ensure visibility when sticky */
  background: var(--surface-primary);
  border-bottom: 1px solid var(--border-subtle);
  box-shadow: var(--shadow-md);
  box-shadow: var(--shadow-lg);
}

.date-navigation {
  display: flex;
  align-items: center;
  gap: var(--space-4);
}

.nav-btn {
  background: linear-gradient(
    135deg,
    var(--glass-bg-soft) 0%,
    var(--glass-bg-light) 100%
  );
  border: 1px solid var(--glass-border);
  color: var(--text-secondary);
  padding: var(--space-3);
  border-radius: var(--radius-md);
  cursor: pointer;
  display: flex;
  align-items: center;
  transition: all var(--duration-normal) var(--spring-smooth);
  box-shadow: var(--shadow-md);
}

.nav-btn:hover {
  background: linear-gradient(
    135deg,
    var(--border-medium) 0%,
    var(--glass-bg-soft) 100%
  );
  border-color: var(--glass-border-medium);
  color: var(--text-primary);
  transform: translateY(-1px);
  box-shadow: var(--shadow-xl);
}

.current-date {
  color: var(--text-primary);
  font-size: var(--text-xl);
  font-weight: var(--font-semibold);
  margin: 0;
  text-shadow: var(--shadow-sm);
}

.header-actions {
  display: flex;
  align-items: center;
  gap: var(--space-4);
}

.today-btn {
  background: var(--state-active-bg);
  border: 1px solid var(--state-active-border);
  backdrop-filter: var(--state-active-glass);
  color: var(--text-primary);
  padding: var(--space-3) var(--space-6);
  border-radius: var(--radius-lg);
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: var(--space-3);
  font-size: var(--text-sm);
  font-weight: var(--font-semibold);
  transition: all var(--duration-normal) var(--spring-bounce);
  box-shadow: var(--state-hover-shadow), var(--state-hover-glow);
}

.today-btn:hover {
  background: var(--state-hover-bg);
  border-color: var(--state-hover-border);
  color: var(--text-primary);
  transform: translateY(-2px);
  box-shadow: var(--state-hover-shadow), var(--state-hover-glow);
}

.view-selector {
  display: flex;
  gap: var(--space-1);
  background: linear-gradient(
    135deg,
    var(--glass-bg-soft) 0%,
    var(--glass-bg-light) 100%
  );
  backdrop-filter: blur(16px);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  padding: var(--space-1);
  box-shadow: inset var(--shadow-sm);
}

.view-btn {
  background: transparent;
  border: none;
  color: var(--text-secondary);
  padding: var(--space-2) var(--space-5);
  border-radius: var(--radius-md);
  cursor: pointer;
  font-size: var(--text-sm);
  font-weight: var(--font-medium);
  transition: all var(--duration-normal) var(--spring-smooth);
}

.view-btn:hover {
  color: var(--text-primary);
  background: var(--glass-bg-heavy);
}

.view-btn.active {
  background: var(--state-active-bg);
  border: 1px solid var(--state-active-border);
  backdrop-filter: var(--state-active-glass);
  color: var(--text-primary);
  box-shadow: var(--state-hover-shadow), var(--state-hover-glow);
}

/* Status Filters - Cohesive Design System */
.status-filters {
  display: flex;
  gap: var(--space-1);
  background: linear-gradient(
    135deg,
    var(--glass-bg-soft) 0%,
    var(--glass-bg-light) 100%
  );
  backdrop-filter: blur(16px);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  padding: var(--space-1);
  box-shadow: inset var(--shadow-sm);
}

.status-btn {
  background: transparent;
  border: 1px solid transparent;
  color: var(--text-secondary);
  padding: var(--space-2) var(--space-4);
  border-radius: var(--radius-md);
  cursor: pointer;
  font-size: var(--text-sm);
  font-weight: var(--font-medium);
  transition: all var(--duration-normal) var(--spring-smooth);
}

.status-btn:hover {
  color: var(--text-primary);
  background: var(--state-hover-bg);
  border-color: var(--state-hover-border);
  backdrop-filter: var(--state-active-glass);
  box-shadow: var(--state-hover-shadow);
}

.status-btn.active {
  color: var(--state-active-text);
  background: var(--state-active-bg);
  border-color: var(--state-active-border);
  backdrop-filter: var(--state-active-glass);
  box-shadow: var(--state-hover-shadow), var(--state-hover-glow);
}

.calendar-grid {
  flex: 1;
  display: grid;
  grid-template-columns: 80px 1fr;
  overflow: hidden;
  min-height: 0; /* Allow flex child to shrink below content size */
}

.time-labels {
  background: linear-gradient(
    135deg,
    var(--glass-bg-tint) 0%,
    var(--glass-bg-weak) 100%
  );
  backdrop-filter: blur(16px);
  border-right: 1px solid var(--glass-border-light);
  overflow-y: auto;
  box-shadow: var(--shadow-xs);
  scrollbar-width: none; /* Firefox */
}

.time-labels::-webkit-scrollbar {
  display: none; /* Chrome/Safari - hide scrollbar but keep functionality */
}

.time-label {
  height: 60px;
  display: flex;
  align-items: flex-start;
  justify-content: flex-end;
  padding-top: var(--space-1);
  padding-right: var(--space-3);
  color: var(--text-muted);
  font-size: var(--text-xs);
  font-weight: var(--font-medium);
  border-bottom: 1px solid var(--glass-bg-tint);
}

.calendar-events-container {
  position: relative;
  background: linear-gradient(
    180deg,
    var(--glass-bg-subtle) 0%,
    transparent 100%
  );
  overflow-y: auto;
}

/* Custom minimalist scrollbar styling */
.calendar-events-container::-webkit-scrollbar {
  width: 6px;
}

.calendar-events-container::-webkit-scrollbar-track {
  background: transparent;
}

.calendar-events-container::-webkit-scrollbar-thumb {
  background: var(--glass-border);
  border-radius: var(--radius-md);
  transition: background var(--transition-fast);
}

.calendar-events-container::-webkit-scrollbar-thumb:hover {
  background: var(--border-hover);
}

/* Firefox scrollbar styling */
.calendar-events-container {
  scrollbar-width: thin;
  scrollbar-color: var(--glass-border) transparent;
}

/* Dark minimalist scrollbar for calendar-main */
.calendar-main::-webkit-scrollbar {
  width: 6px;
}

.calendar-main::-webkit-scrollbar-track {
  background: transparent;
}

.calendar-main::-webkit-scrollbar-thumb {
  background: var(--glass-border);
  border-radius: var(--radius-md);
  transition: background var(--transition-fast);
}

.calendar-main::-webkit-scrollbar-thumb:hover {
  background: var(--border-hover);
}

.calendar-main {
  scrollbar-width: thin;
  scrollbar-color: var(--glass-border) transparent;
}

.time-grid {
  position: relative;
  z-index: 1;
}

.time-slot {
  height: 30px;
  border-bottom: 1px solid var(--glass-bg-light);
  position: relative;
  transition: all var(--duration-fast) var(--spring-smooth);
}

.time-slot:hover {
  background: linear-gradient(
    135deg,
    var(--calendar-hover-bg-medium) 0%,
    var(--calendar-hover-bg) 100%
  );
  cursor: crosshair;
}

.time-slot.creating {
  background: linear-gradient(
    135deg,
    var(--calendar-creating-bg) 0%,
    var(--calendar-creating-bg-alt) 100%
  );
  border-color: var(--calendar-creating-border);
}

.current-time-layer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 50;
  pointer-events: none;
}

.time-indicator {
  height: 30px;
  pointer-events: none;
  position: relative;
  z-index: 50;
}

.time-indicator.current-time {
  height: 0;
  border-top: 2px solid var(--calendar-current-time-border);
  box-shadow: var(--calendar-current-time-glow);
}

.ghost-preview {
  position: absolute;
  z-index: 5;
  background: linear-gradient(
    135deg,
    var(--calendar-ghost-bg-start) 0%,
    var(--calendar-ghost-bg-end) 100%
  );
  backdrop-filter: blur(8px);
  border: 2px dashed var(--calendar-ghost-border);
  border-radius: var(--radius-lg);
  pointer-events: none;
  animation: ghostPulse 1.5s ease-in-out infinite;
  box-shadow: var(--calendar-ghost-shadow);
}

.ghost-content {
  padding: var(--space-3);
  display: flex;
  flex-direction: column;
  justify-content: center;
  height: 100%;
}

.ghost-title {
  color: var(--text-primary);
  font-size: var(--text-sm);
  font-weight: var(--font-semibold);
  opacity: 0.9;
  margin-bottom: var(--space-1);
}

.ghost-duration {
  color: var(--text-secondary);
  font-size: var(--text-xs);
  opacity: 0.8;
}

@keyframes ghostPulse {
  0%, 100% {
    opacity: 0.6;
  }
  50% {
    opacity: 0.9;
  }
}

.events-layer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  z-index: 10;
  pointer-events: none;
}

.calendar-event {
  position: absolute;
  z-index: 1;
  border-radius: var(--radius-lg);
  border: 1px solid var(--border-subtle);
  /* Dark solid background like kanban */
  background: var(--surface-tertiary);
  color: var(--text-primary);
  font-weight: var(--font-medium);
  overflow: visible;
  display: flex;
  flex-direction: column;
  transition: all var(--duration-normal) var(--spring-smooth);
  pointer-events: auto;
  box-shadow: var(--shadow-sm);
}

.calendar-event:hover {
  background: var(--state-hover-bg);
  border-color: var(--state-hover-border);
  backdrop-filter: var(--state-active-glass);
  transform: translateY(-1px);
  box-shadow: var(--state-hover-shadow), var(--state-hover-glow);
}

/* Active pomodoro timer highlight */
.calendar-event.timer-active-event {
  border: 2px solid var(--timer-active-border);
  background: linear-gradient(
    135deg,
    var(--timer-active-bg-start) 0%,
    var(--timer-active-bg-end) 100%
  );
  box-shadow:
    var(--timer-active-glow),
    var(--timer-active-shadow),
    inset 0 1px 0 var(--glass-border-hover);
  animation: timerPulse 2s ease-in-out infinite;
}

@keyframes timerPulse {
  0%, 100% {
    box-shadow:
      var(--timer-active-glow),
      var(--timer-active-shadow),
      inset 0 1px 0 var(--glass-border-hover);
  }
  50% {
    box-shadow:
      var(--timer-active-glow-strong),
      var(--timer-active-shadow-hover),
      inset 0 1px 0 var(--border-hover);
  }
}

.calendar-event.multi-slot {
  min-height: 60px;
}

/* Priority stripe - matching kanban/inbox pattern */
.calendar-event .priority-stripe {
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  border-radius: var(--radius-sm) 0 0 var(--radius-sm);
}

.calendar-event .priority-stripe.priority-high {
  background: linear-gradient(180deg, var(--color-priority-high) 0%, #ff6b6b 100%);
  box-shadow: 0 0 8px rgba(255, 107, 107, 0.3);
}

.calendar-event .priority-stripe.priority-medium {
  background: linear-gradient(180deg, var(--color-priority-medium) 0%, #feca57 100%);
  box-shadow: 0 0 8px rgba(254, 202, 87, 0.3);
}

.calendar-event .priority-stripe.priority-low {
  background: linear-gradient(180deg, var(--color-priority-low) 0%, #48dbfb 100%);
  box-shadow: 0 0 8px rgba(72, 219, 251, 0.3);
}

.resize-handle {
  position: absolute;
  left: 0;
  right: 0;
  height: 24px;
  background: transparent;
  cursor: ns-resize;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all var(--transition-fast);
  z-index: 20;
  opacity: 0;
  pointer-events: none;
}

.calendar-event:hover .resize-handle {
  opacity: 1;
  pointer-events: auto;
}

.resize-handle.resize-top {
  top: -12px;
}

.resize-handle.resize-bottom {
  bottom: -12px;
}

.resize-handle:hover {
  background: var(--glass-border);
}

.resize-handle::after {
  content: '';
  width: 24px;
  height: 3px;
  background: var(--glass-handle);
  border-radius: var(--radius-xs);
  transition: all var(--transition-fast);
}

.resize-handle:hover::after {
  background: var(--brand-primary);
  height: 4px;
  width: 32px;
}

.calendar-event[data-duration="30"] .resize-handle {
  height: 8px;
}

.calendar-event[data-duration="30"] .resize-handle.resize-top {
  top: 0;
}

.calendar-event[data-duration="30"] .resize-handle.resize-bottom {
  bottom: 0;
}

/* 30-minute tasks: horizontal layout */
.calendar-event[data-duration="30"] .event-content {
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: var(--space-1) var(--space-3);
}

.calendar-event[data-duration="30"] .event-title {
  margin-bottom: 0;
  margin-right: var(--space-2);
}

.event-content {
  flex: 1;
  padding: var(--space-3);
  cursor: move;
  transition: all var(--transition-fast);
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.event-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--space-1);
}

.status-indicator {
  background: var(--glass-bg-soft);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-full);
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  cursor: pointer;
  transition: all var(--transition-fast);
  flex-shrink: 0;
  margin-left: var(--space-2);
}

.status-indicator:hover {
  background: var(--glass-bg-heavy);
  border-color: var(--brand-primary);
  transform: scale(1.1);
}

.status-indicator.status-planned {
  background: var(--brand-primary-bg-subtle);
  border-color: var(--brand-primary-border-medium);
  color: var(--brand-primary);
}

.status-indicator.status-in_progress {
  background: var(--color-priority-medium-bg-subtle);
  border-color: var(--color-priority-medium-border-medium);
  color: var(--color-priority-medium);
}

.status-indicator.status-done {
  background: var(--color-work-bg-subtle);
  border-color: var(--color-work-border-medium);
  color: var(--color-work);
}

.status-indicator.status-backlog,
.status-indicator.status-on_hold {
  background: var(--glass-bg-tint);
  border-color: var(--glass-bg-heavy);
  color: var(--text-muted);
}

.event-title {
  font-size: var(--text-sm);
  font-weight: var(--font-semibold);
  line-height: 1.4;
  margin-bottom: var(--space-1);
  word-wrap: break-word;
  overflow: visible;
}

.event-duration {
  font-size: var(--text-xs);
  opacity: 0.8;
}

/* Week View Styles */
.week-view {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.week-header {
  display: grid;
  grid-template-columns: 80px repeat(7, 1fr);
  background: linear-gradient(
    135deg,
    var(--glass-bg-heavy) 0%,
    var(--glass-bg-tint) 100%
  );
  backdrop-filter: blur(24px);
  border-bottom: 1px solid var(--glass-bg-heavy);
  min-height: 80px;
  flex-shrink: 0;
  box-shadow: var(--shadow-md);
}

.week-time-label {
  background: linear-gradient(
    135deg,
    var(--glass-bg-tint) 0%,
    var(--glass-bg-weak) 100%
  );
}

.week-day-header {
  padding: var(--space-4);
  text-align: center;
  border-left: 1px solid var(--glass-border-light);
  display: flex;
  flex-direction: column;
  justify-content: center;
  transition: all var(--duration-fast) var(--spring-smooth);
}

.week-day-header:hover {
  background: var(--glass-bg-tint);
}

.week-day-name {
  font-size: var(--text-sm);
  font-weight: var(--font-semibold);
  color: var(--text-secondary);
  text-transform: uppercase;
  margin-bottom: var(--space-1);
}

.week-day-date {
  font-size: var(--text-xl);
  font-weight: var(--font-bold);
  color: var(--text-primary);
}

.week-grid-container {
  flex: 1;
  display: grid;
  grid-template-columns: 80px 1fr;
  overflow: hidden;
}

.week-time-labels {
  background: var(--bg-secondary);
  border-right: 1px solid var(--border-primary);
  overflow: hidden;
}

.week-time-label {
  height: 60px;
  display: flex;
  align-items: flex-start;
  justify-content: flex-end;
  padding-top: 0.25rem;
  padding-right: 0.5rem;
  color: var(--text-muted);
  font-size: var(--text-xs);
  font-weight: var(--font-medium);
  border-bottom: 1px solid var(--border-primary);
}

.week-days-grid {
  position: relative;
  overflow-y: auto;
  background: var(--surface-primary);
}

/* Custom minimalist scrollbar for week view */
.week-days-grid::-webkit-scrollbar {
  width: 6px;
}

.week-days-grid::-webkit-scrollbar-track {
  background: transparent;
}

.week-days-grid::-webkit-scrollbar-thumb {
  background: var(--glass-border);
  border-radius: var(--radius-md);
  transition: background var(--transition-fast);
}

.week-days-grid::-webkit-scrollbar-thumb:hover {
  background: var(--border-hover);
}

.week-days-grid {
  scrollbar-width: thin;
  scrollbar-color: var(--glass-border) transparent;
}

.week-time-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  position: relative;
  z-index: 1;
  pointer-events: none;
}

.week-time-grid > * {
  pointer-events: auto;
}

.week-day-column {
  border-left: 1px solid var(--border-primary);
}

.week-day-column:first-child {
  border-left: none;
}

.week-time-cell {
  height: 60px;
  border-bottom: 1px solid var(--border-primary);
  transition: all var(--transition-fast);
}

.week-time-cell:hover {
  background: var(--week-hover-bg);
}

.week-events-layer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  z-index: 10;
  pointer-events: none;
}

.week-current-time-layer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 50;
  pointer-events: none;
  display: grid;
  grid-template-columns: repeat(7, 1fr);
}

.week-day-time-column {
  display: flex;
  flex-direction: column;
  position: relative;
}

.week-time-indicator {
  height: 60px;
  pointer-events: none;
  position: relative;
  z-index: 50;
}

.week-time-indicator.current-time {
  height: 0;
  border-top: 2px solid var(--calendar-current-time-border);
  box-shadow: var(--calendar-current-time-glow);
}

.week-event {
  position: relative;
  z-index: 1;
  border-radius: var(--radius-lg);
  border: 1px solid var(--border-subtle);
  /* Dark solid background like kanban */
  background: var(--surface-tertiary);
  color: var(--text-primary);
  font-weight: var(--font-medium);
  padding: var(--space-2) var(--space-3);
  overflow: hidden;
  transition: all var(--duration-normal) var(--spring-smooth);
  pointer-events: auto;
  cursor: move;
  box-shadow: var(--shadow-sm);
  display: flex;
  flex-direction: column;
}

.week-event:hover {
  background: var(--state-hover-bg);
  border-color: var(--state-hover-border);
  backdrop-filter: var(--state-active-glass);
  transform: translateY(-1px);
  box-shadow: var(--state-hover-shadow), var(--state-hover-glow);
}

/* Priority stripe for week events */
.week-event .priority-stripe {
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  border-radius: var(--radius-sm) 0 0 var(--radius-sm);
}

.week-event .priority-stripe.priority-high {
  background: linear-gradient(180deg, var(--color-priority-high) 0%, #ff6b6b 100%);
  box-shadow: 0 0 8px rgba(255, 107, 107, 0.3);
}

.week-event .priority-stripe.priority-medium {
  background: linear-gradient(180deg, var(--color-priority-medium) 0%, #feca57 100%);
  box-shadow: 0 0 8px rgba(254, 202, 87, 0.3);
}

.week-event .priority-stripe.priority-low {
  background: linear-gradient(180deg, var(--color-priority-low) 0%, #48dbfb 100%);
  box-shadow: 0 0 8px rgba(72, 219, 251, 0.3);
}

/* Week view active pomodoro highlight */
.week-event.timer-active-event {
  border: 2px solid var(--timer-active-border);
  background: linear-gradient(
    135deg,
    var(--timer-active-bg-start) 0%,
    var(--timer-active-bg-end) 100%
  );
  box-shadow:
    var(--timer-active-glow),
    var(--shadow-md),
    inset 0 1px 0 var(--border-medium);
  animation: timerPulse 2s ease-in-out infinite;
}

.week-event .event-title {
  font-size: var(--text-sm);
  font-weight: var(--font-semibold);
  line-height: 1.4;
  margin-bottom: var(--space-1);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.week-event .event-duration {
  font-size: var(--text-xs);
  opacity: 0.8;
}

.week-event .event-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding: 0;
}

.week-event .event-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--space-1);
}

.week-event .status-indicator {
  background: var(--glass-bg-soft);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-full);
  width: 18px;
  height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 9px;
  cursor: pointer;
  transition: all var(--transition-fast);
  flex-shrink: 0;
  margin-left: var(--space-2);
}

.week-event .status-indicator:hover {
  background: var(--glass-bg-heavy);
  border-color: var(--brand-primary);
  transform: scale(1.1);
}

.week-event .status-indicator.status-planned {
  background: var(--brand-primary-bg-subtle);
  border-color: var(--brand-primary-border-medium);
  color: var(--brand-primary);
}

.week-event .status-indicator.status-in_progress {
  background: var(--color-priority-medium-bg-subtle);
  border-color: var(--color-priority-medium-border-medium);
  color: var(--color-priority-medium);
}

.week-event .status-indicator.status-done {
  background: var(--color-work-bg-subtle);
  border-color: var(--color-work-border-medium);
  color: var(--color-work);
}

.week-event .status-indicator.status-backlog,
.week-event .status-indicator.status-on_hold {
  background: var(--glass-bg-tint);
  border-color: var(--glass-bg-heavy);
  color: var(--text-muted);
}

/* Week view resize handles */
.week-event .resize-handle {
  position: absolute;
  left: 0;
  right: 0;
  height: 24px;
  background: transparent;
  cursor: ns-resize;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all var(--transition-fast);
  z-index: 20;
  opacity: 0;
  pointer-events: none;
}

.week-event:hover .resize-handle {
  opacity: 1;
  pointer-events: auto;
}

.week-event .resize-handle.resize-top {
  top: -12px;
}

.week-event .resize-handle.resize-bottom {
  bottom: -12px;
}

.week-event .resize-handle:hover {
  background: var(--glass-border);
}

.week-event .resize-handle::after {
  content: '';
  width: 24px;
  height: 3px;
  background: var(--glass-handle);
  border-radius: var(--radius-xs);
  transition: all var(--transition-fast);
}

.week-event .resize-handle:hover::after {
  background: var(--brand-primary);
  height: 4px;
  width: 32px;
}

/* 30-minute tasks in week view */
.week-event[data-duration="30"] .resize-handle {
  height: 8px;
}

.week-event[data-duration="30"] .resize-handle.resize-top {
  top: 0;
}

.week-event[data-duration="30"] .resize-handle.resize-bottom {
  bottom: 0;
}

.week-event[data-duration="30"] .event-content {
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 0;
}

.week-event[data-duration="30"] .event-title {
  margin-bottom: 0;
  margin-right: var(--space-2);
  flex: 1;
}

/* Month View Styles */
.month-view {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.month-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  grid-template-rows: repeat(6, 1fr);
  flex: 1;
  gap: 1px;
  background: var(--border-primary);
}

.month-day-cell {
  background: linear-gradient(
    135deg,
    var(--glass-bg-light) 0%,
    var(--glass-bg-subtle) 100%
  );
  padding: var(--space-2);
  display: flex;
  flex-direction: column;
  min-height: 100px;
  cursor: pointer;
  transition: all var(--duration-fast) var(--spring-smooth);
  overflow: hidden;
}

.month-day-cell:hover {
  background: linear-gradient(
    135deg,
    var(--glass-bg-heavy) 0%,
    var(--glass-bg-tint) 100%
  );
  backdrop-filter: blur(8px);
}

.month-day-cell.other-month {
  background: var(--glass-bg-subtle);
  opacity: 0.4;
}

.month-day-cell.today {
  background: linear-gradient(
    135deg,
    var(--calendar-today-bg-start) 0%,
    var(--calendar-today-bg-end) 100%
  );
  border: 1px solid var(--calendar-today-border);
  box-shadow: var(--calendar-today-glow);
}

.month-day-cell.today .day-number {
  background: linear-gradient(
    135deg,
    var(--calendar-today-badge-start) 0%,
    var(--calendar-today-badge-end) 100%
  );
  color: white;
  border-radius: var(--radius-full);
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: var(--calendar-today-badge-shadow);
}

.day-number {
  font-weight: var(--font-semibold);
  font-size: var(--text-sm);
  color: var(--text-primary);
  margin-bottom: var(--space-2);
}

.day-events {
  display: flex;
  flex-direction: column;
  gap: 2px;
  overflow-y: auto;
}

.month-event {
  font-size: var(--text-xs);
  padding: var(--space-1) var(--space-2);
  border-radius: var(--radius-md);
  color: var(--text-primary);
  cursor: move;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  display: flex;
  gap: var(--space-1);
  align-items: center;
  transition: all var(--duration-fast) var(--spring-smooth);
  border: 1px solid var(--glass-border-medium);
  background: linear-gradient(
    135deg,
    var(--glass-bg-heavy) 0%,
    var(--glass-bg-tint) 100%
  );
  backdrop-filter: blur(8px);
  box-shadow: var(--shadow-sm);
}

.month-event:hover {
  border-color: var(--glass-border-strong);
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
  background: linear-gradient(
    135deg,
    var(--border-medium) 0%,
    var(--glass-bg-soft) 100%
  );
}

/* Priority stripe for month events */
.month-event .priority-stripe {
  position: absolute;
  top: 0;
  left: 0;
  width: 3px;
  height: 100%;
  border-radius: var(--radius-sm) 0 0 var(--radius-sm);
}

.month-event .priority-stripe.priority-high {
  background: linear-gradient(180deg, var(--color-priority-high) 0%, #ff6b6b 100%);
}

.month-event .priority-stripe.priority-medium {
  background: linear-gradient(180deg, var(--color-priority-medium) 0%, #feca57 100%);
}

.month-event .priority-stripe.priority-low {
  background: linear-gradient(180deg, var(--color-priority-low) 0%, #48dbfb 100%);
}

/* Month view active pomodoro highlight */
.month-event.timer-active-event {
  border: 2px solid var(--timer-active-border);
  background: linear-gradient(
    135deg,
    var(--timer-active-month-bg-start) 0%,
    var(--timer-active-month-bg-end) 100%
  );
  box-shadow:
    var(--timer-active-month-glow),
    var(--shadow-md);
  animation: timerPulse 2s ease-in-out infinite;
  font-weight: var(--font-semibold);
}

.event-time {
  font-weight: var(--font-medium);
  opacity: 0.9;
}

.event-title-short {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
}
</style>