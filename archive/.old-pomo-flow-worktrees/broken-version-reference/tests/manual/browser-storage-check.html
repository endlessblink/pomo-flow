<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pomo-Flow Task Data Recovery</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #2563eb;
        }
        pre {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            border: 1px solid #e9ecef;
        }
        .result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
        }
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }
        .task-item {
            background: #f1f5f9;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 4px solid #3b82f6;
        }
        .task-title {
            font-weight: bold;
            color: #1e40af;
        }
        .task-details {
            font-size: 0.9em;
            color: #64748b;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>üîç Pomo-Flow Task Data Recovery Tool</h1>

    <div class="container">
        <h2>Browser Storage Analysis</h2>
        <p>This tool will search all browser storage locations for your original Pomo-Flow tasks.</p>

        <button onclick="checkAllStorage()">üîé Check All Storage Locations</button>
        <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
        <button onclick="exportData()">üíæ Export Found Data</button>
    </div>

    <div id="results"></div>

    <script>
        let foundData = {
            indexedDB: {},
            localStorage: {},
            sessionStorage: {},
            results: []
        };

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            foundData = {
                indexedDB: {},
                localStorage: {},
                sessionStorage: {},
                results: []
            };
        }

        function addResult(title, content, type = 'success') {
            const resultsDiv = document.getElementById('results');
            const resultDiv = document.createElement('div');
            resultDiv.className = `container ${type}`;
            resultDiv.innerHTML = `
                <h3>${title}</h3>
                <div class="result ${type}">${content}</div>
            `;
            resultsDiv.appendChild(resultDiv);
        }

        function formatTask(task) {
            return `
                <div class="task-item">
                    <div class="task-title">${task.title || 'Untitled Task'}</div>
                    <div class="task-details">
                        Status: ${task.status || 'unknown'} |
                        Priority: ${task.priority || 'unknown'} |
                        Project: ${task.projectId || task.project || 'unknown'}<br>
                        Created: ${task.createdAt ? new Date(task.createdAt).toLocaleString() : 'unknown'}<br>
                        ${task.description ? `Description: ${task.description.substring(0, 100)}${task.description.length > 100 ? '...' : ''}` : ''}
                    </div>
                </div>
            `;
        }

        async function checkIndexedDB() {
            return new Promise((resolve) => {
                const result = { databases: [], taskData: [] };

                // Check if IndexedDB is supported
                if (!window.indexedDB) {
                    result.error = 'IndexedDB not supported';
                    resolve(result);
                    return;
                }

                const request = indexedDB.databases();
                request.then(databases => {
                    result.databases = databases;

                    // Try to open each database and look for task data
                    const promises = databases.map(async db => {
                        try {
                            const dbInstance = await openDatabase(db.name);
                            const stores = getAllObjectStores(dbInstance);
                            const tasks = [];

                            for (const store of stores) {
                                const storeData = await getAllFromStore(dbInstance, store);
                                // Look for task-like objects
                                const taskLikeData = storeData.filter(item =>
                                    item && typeof item === 'object' && (
                                        item.title ||
                                        item.taskTitle ||
                                        item.name ||
                                        (item.id && (item.status || item.priority || item.projectId))
                                    )
                                );
                                tasks.push(...taskLikeData);
                            }

                            if (tasks.length > 0) {
                                result.taskData.push({ database: db.name, tasks });
                            }

                            dbInstance.close();
                        } catch (error) {
                            console.warn(`Could not access database ${db.name}:`, error);
                        }
                    });

                    Promise.all(promises).then(() => {
                        resolve(result);
                    });
                }).catch(error => {
                    result.error = error.message;
                    resolve(result);
                });
            });
        }

        function openDatabase(name) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(name);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        function getAllObjectStores(db) {
            const stores = [];
            for (let i = 0; i < db.objectStoreNames.length; i++) {
                stores.push(db.objectStoreNames[i]);
            }
            return stores;
        }

        function getAllFromStore(db, storeName) {
            return new Promise((resolve) => {
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => resolve([]);
            });
        }

        function checkLocalStorage() {
            const result = {};
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                const value = localStorage.getItem(key);
                try {
                    const parsed = JSON.parse(value);
                    if (Array.isArray(parsed) && parsed.length > 0 &&
                        parsed[0] && typeof parsed[0] === 'object' &&
                        (parsed[0].title || parsed[0].taskTitle || parsed[0].name)) {
                        result[key] = parsed;
                    }
                } catch (e) {
                    // Not JSON, skip
                }
            }
            return result;
        }

        function checkSessionStorage() {
            const result = {};
            for (let i = 0; i < sessionStorage.length; i++) {
                const key = sessionStorage.key(i);
                const value = sessionStorage.getItem(key);
                try {
                    const parsed = JSON.parse(value);
                    if (Array.isArray(parsed) && parsed.length > 0 &&
                        parsed[0] && typeof parsed[0] === 'object' &&
                        (parsed[0].title || parsed[0].taskTitle || parsed[0].name)) {
                        result[key] = parsed;
                    }
                } catch (e) {
                    // Not JSON, skip
                }
            }
            return result;
        }

        async function checkAllStorage() {
            clearResults();
            addResult('üîç Starting Storage Analysis', 'Checking all browser storage locations for task data...', 'warning');

            // Check IndexedDB
            addResult('üìä Checking IndexedDB', 'Analyzing IndexedDB databases...', 'warning');
            const indexedDBResult = await checkIndexedDB();
            foundData.indexedDB = indexedDBResult;

            if (indexedDBResult.error) {
                addResult('‚ùå IndexedDB Error', indexedDBResult.error, 'error');
            } else {
                if (indexedDBResult.databases.length === 0) {
                    addResult('üì≠ IndexedDB', 'No IndexedDB databases found', 'warning');
                } else {
                    let dbInfo = `<strong>Found ${indexedDBResult.databases.length} databases:</strong><br>`;
                    indexedDBResult.databases.forEach(db => {
                        dbInfo += `- ${db.name} (version ${db.version})<br>`;
                    });
                    addResult('üìä IndexedDB Databases', dbInfo, 'success');

                    // Show task data if found
                    if (indexedDBResult.taskData.length > 0) {
                        indexedDBResult.taskData.forEach(dbData => {
                            let taskInfo = `<strong>Found ${dbData.tasks.length} task-like items in database "${dbData.database}":</strong><br>`;
                            dbData.tasks.slice(0, 5).forEach(task => {
                                taskInfo += formatTask(task);
                            });
                            if (dbData.tasks.length > 5) {
                                taskInfo += `<p><em>... and ${dbData.tasks.length - 5} more tasks</em></p>`;
                            }
                            addResult(`üìã Tasks from ${dbData.database}`, taskInfo, 'success');
                        });
                    }
                }
            }

            // Check Local Storage
            addResult('üíæ Checking Local Storage', 'Analyzing localStorage...', 'warning');
            const localStorageResult = checkLocalStorage();
            foundData.localStorage = localStorageResult;

            if (Object.keys(localStorageResult).length === 0) {
                addResult('üíæ Local Storage', 'No task data found in localStorage', 'warning');
            } else {
                Object.entries(localStorageResult).forEach(([key, tasks]) => {
                    let taskInfo = `<strong>Found ${tasks.length} tasks in localStorage key "${key}":</strong><br>`;
                    tasks.slice(0, 5).forEach(task => {
                        taskInfo += formatTask(task);
                    });
                    if (tasks.length > 5) {
                        taskInfo += `<p><em>... and ${tasks.length - 5} more tasks</em></p>`;
                    }
                    addResult(`üíæ Local Storage: ${key}`, taskInfo, 'success');
                });
            }

            // Check Session Storage
            addResult('üîÑ Checking Session Storage', 'Analyzing sessionStorage...', 'warning');
            const sessionStorageResult = checkSessionStorage();
            foundData.sessionStorage = sessionStorageResult;

            if (Object.keys(sessionStorageResult).length === 0) {
                addResult('üîÑ Session Storage', 'No task data found in sessionStorage', 'warning');
            } else {
                Object.entries(sessionStorageResult).forEach(([key, tasks]) => {
                    let taskInfo = `<strong>Found ${tasks.length} tasks in sessionStorage key "${key}":</strong><br>`;
                    tasks.slice(0, 5).forEach(task => {
                        taskInfo += formatTask(task);
                    });
                    if (tasks.length > 5) {
                        taskInfo += `<p><em>... and ${tasks.length - 5} more tasks</em></p>`;
                    }
                    addResult(`üîÑ Session Storage: ${key}`, taskInfo, 'success');
                });
            }

            // Summary
            const totalTasks = [
                ...Object.values(foundData.localStorage).flat(),
                ...Object.values(foundData.sessionStorage).flat(),
                ...foundData.indexedDB.taskData.flatMap(db => db.tasks)
            ].length;

            if (totalTasks === 0) {
                addResult('‚ùå No Task Data Found', 'No personal task data was found in any storage location. Only sample/development tasks may exist in the application.', 'error');
            } else {
                addResult('‚úÖ Task Data Recovery Complete', `Found a total of ${totalTasks} task items across all storage locations. Use the Export button to download all data.`, 'success');
            }
        }

        function exportData() {
            const allTasks = [];

            // Collect all tasks from all sources
            Object.entries(foundData.localStorage).forEach(([key, tasks]) => {
                tasks.forEach(task => {
                    allTasks.push({ ...task, _source: `localStorage:${key}` });
                });
            });

            Object.entries(foundData.sessionStorage).forEach(([key, tasks]) => {
                tasks.forEach(task => {
                    allTasks.push({ ...task, _source: `sessionStorage:${key}` });
                });
            });

            foundData.indexedDB.taskData.forEach(dbData => {
                dbData.tasks.forEach(task => {
                    allTasks.push({ ...task, _source: `indexedDB:${dbData.database}` });
                });
            });

            if (allTasks.length === 0) {
                addResult('‚ùå No Data to Export', 'No task data found to export.', 'error');
                return;
            }

            // Create and download JSON file
            const dataStr = JSON.stringify(allTasks, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `pomo-flow-tasks-recovery-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            addResult('‚úÖ Export Complete', `Exported ${allTasks.length} tasks to pomo-flow-tasks-recovery-${new Date().toISOString().split('T')[0]}.json`, 'success');
        }

        // Auto-run when page loads
        window.onload = () => {
            addResult('üöÄ Ready', 'Task Recovery Tool loaded. Click "Check All Storage Locations" to begin.', 'success');
        };
    </script>
</body>
</html>