<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Undo/Redo Test</title>
    <style>
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .test-header {
            text-align: center;
            margin-bottom: 30px;
        }
        .test-status {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .test-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(238, 90, 36, 0.3);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(238, 90, 36, 0.4);
        }
        .btn.success {
            background: linear-gradient(135deg, #51cf66, #40c057);
            box-shadow: 0 4px 15px rgba(64, 192, 87, 0.3);
        }
        .btn.success:hover {
            box-shadow: 0 6px 20px rgba(64, 192, 87, 0.4);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        iframe {
            width: 100%;
            height: 600px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: white;
        }
        .log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-indicator.running {
            background: #ffd43b;
            animation: pulse 1.5s infinite;
        }
        .status-indicator.success {
            background: #51cf66;
        }
        .status-indicator.error {
            background: #ff6b6b;
        }
        .status-indicator.pending {
            background: #868e96;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .metric {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }
        .metric-value {
            font-weight: bold;
            color: #51cf66;
        }
        .instructions {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid #51cf66;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="test-header">
            <h1>üß™ Comprehensive Undo/Redo Test Suite</h1>
            <p>Testing canvas deletion with proper undo/redo functionality</p>
        </div>

        <div class="instructions">
            <h3>üìã Test Instructions:</h3>
            <ol>
                <li><strong>Start Test:</strong> Click "Start Automated Test" below</li>
                <li><strong>Watch Progress:</strong> The test will automatically create tasks, delete them, and test undo</li>
                <li><strong>Manual Testing:</strong> After automated test, you can manually test using keyboard shortcuts</li>
                <li><strong>Expected Results:</strong> All deletion methods should increment undo count and Cmd+Z should restore tasks</li>
            </ol>
        </div>

        <div class="test-grid">
            <div class="test-card">
                <h3>üéØ Test Status</h3>
                <div class="metric">
                    <span>Test State:</span>
                    <span class="status-indicator pending" id="testStatus"></span>
                    <span id="testStateText">Ready</span>
                </div>
                <div class="metric">
                    <span>Tests Completed:</span>
                    <span class="metric-value" id="testsCompleted">0/6</span>
                </div>
                <div class="metric">
                    <span>Current Server:</span>
                    <span class="metric-value" id="serverPort">5550</span>
                </div>
                <div class="metric">
                    <span>Undo Stack Size:</span>
                    <span class="metric-value" id="undoStackSize">0</span>
                </div>
                <div class="metric">
                    <span>Can Undo:</span>
                    <span class="metric-value" id="canUndo">false</span>
                </div>
            </div>

            <div class="test-card">
                <h3>üéÆ Test Controls</h3>
                <button class="btn" id="startTest" onclick="startAutomatedTest()">Start Automated Test</button>
                <button class="btn success" id="manualTest" onclick="enableManualTest()">Enable Manual Testing</button>
                <button class="btn" id="resetTest" onclick="resetTest()">Reset Test</button>
                <div class="log" id="testLog">üìä Test log will appear here...</div>
            </div>

            <div class="test-card">
                <h3>‚å®Ô∏è Manual Test Commands</h3>
                <p><strong>After enabling manual testing:</strong></p>
                <ul>
                    <li><code>Delete</code> - Delete selected task</li>
                    <li><code>Shift+Delete</code> - Force delete task</li>
                    <li><code>Backspace</code> - Delete task (backspace mode)</li>
                    <li><code>Cmd+Z</code> (Mac) or <code>Ctrl+Z</code> - Undo last action</li>
                    <li><code>Cmd+Shift+Z</code> or <code>Ctrl+Y</code> - Redo action</li>
                </ul>
                <div class="metric">
                    <span>Manual Mode:</span>
                    <span class="status-indicator pending" id="manualMode"></span>
                    <span id="manualModeText">Disabled</span>
                </div>
            </div>
        </div>

        <div class="test-status">
            <h3>üñ•Ô∏è Live Canvas View</h3>
            <iframe id="canvasFrame" src="http://localhost:5550/#/canvas" title="Canvas View"></iframe>
        </div>
    </div>

    <script>
        let testWindow = null;
        let testInterval = null;
        let currentTest = 0;
        let testResults = [];

        const tests = [
            { name: 'Create Test Task', action: 'create' },
            { name: 'Delete with Delete Key', action: 'delete' },
            { name: 'Verify Undo Count Incremented', action: 'verifyUndo' },
            { name: 'Test Undo with Cmd+Z', action: 'undo' },
            { name: 'Verify Task Restored', action: 'verifyRestore' },
            { name: 'Test Shift+Delete', action: 'shiftDelete' }
        ];

        function log(message, type = 'info') {
            const logElement = document.getElementById('testLog');
            const timestamp = new Date().toLocaleTimeString();
            const icons = {
                'info': 'üìä',
                'success': '‚úÖ',
                'error': '‚ùå',
                'warning': '‚ö†Ô∏è',
                'test': 'üß™'
            };

            logElement.innerHTML += `<div>${icons[type]} [${timestamp}] ${message}</div>`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function updateStatus(status, text) {
            const indicator = document.getElementById('testStatus');
            const textElement = document.getElementById('testStateText');

            indicator.className = `status-indicator ${status}`;
            textElement.textContent = text;
        }

        function updateMetrics() {
            if (testWindow && testWindow.undoStore) {
                document.getElementById('undoStackSize').textContent = testWindow.undoStore.undoCount || 0;
                document.getElementById('canUndo').textContent = testWindow.undoStore.canUndo || false;
            }
        }

        async function waitForCanvas() {
            log('Waiting for canvas to load...', 'info');

            // Wait for iframe to load
            const frame = document.getElementById('canvasFrame');
            await new Promise(resolve => {
                if (frame.contentWindow && frame.contentWindow.document.readyState === 'complete') {
                    resolve();
                } else {
                    frame.onload = resolve;
                }
            });

            // Give additional time for Vue app to initialize
            await new Promise(resolve => setTimeout(resolve, 3000));

            testWindow = frame.contentWindow;

            // Try to access the Vue app
            try {
                const app = testWindow.document.querySelector('#app').__vue_app__;
                const canvasComponent = app._instance.components.find(c => c.type?.name === 'CanvasView');

                if (canvasComponent?.setupState?.undoRedoStore) {
                    testWindow.undoStore = canvasComponent.setupState.undoRedoStore;
                    testWindow.canvasComponent = canvasComponent;
                    log('Canvas and undo store found successfully!', 'success');
                    updateMetrics();
                    return true;
                } else {
                    log('Undo store not found in canvas component', 'error');
                    return false;
                }
            } catch (error) {
                log(`Error accessing canvas: ${error.message}`, 'error');
                return false;
            }
        }

        async function createTestTask() {
            log('Creating test task on canvas...', 'test');

            try {
                // Click on canvas to create task
                const canvas = testWindow.document.querySelector('.vue-flow__pane');
                if (!canvas) {
                    throw new Error('Canvas not found');
                }

                canvas.click({ clientX: 300, clientY: 300 });
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Fill in task details
                const titleInput = testWindow.document.querySelector('input[placeholder*="title"], input[data-testid*="title"], input[type="text"]');
                if (titleInput) {
                    titleInput.value = 'Test Undo Task';
                    titleInput.dispatchEvent(new Event('input', { bubbles: true }));
                }

                const createBtn = testWindow.document.querySelector('button[type="submit"], button[data-testid*="create"], button:contains("Create")');
                if (createBtn) {
                    createBtn.click();
                }

                await new Promise(resolve => setTimeout(resolve, 2000));

                const nodes = testWindow.document.querySelectorAll('.vue-flow__node');
                log(`Task created successfully. Found ${nodes.length} nodes on canvas`, 'success');
                return nodes.length > 0;
            } catch (error) {
                log(`Failed to create task: ${error.message}`, 'error');
                return false;
            }
        }

        async function selectAndDeleteTask() {
            log('Selecting and deleting task with Delete key...', 'test');

            try {
                const nodes = testWindow.document.querySelectorAll('.vue-flow__node');
                if (nodes.length === 0) {
                    throw new Error('No tasks found to delete');
                }

                // Select first node
                const firstNode = nodes[0];
                firstNode.click();
                log('Task selected', 'info');

                // Record undo state before deletion
                const undoCountBefore = testWindow.undoStore.undoCount;
                log(`Undo count before deletion: ${undoCountBefore}`, 'info');

                // Send Delete key event
                testWindow.document.dispatchEvent(new testWindow.KeyboardEvent('keydown', {
                    key: 'Delete',
                    bubbles: true,
                    cancelable: true
                }));

                await new Promise(resolve => setTimeout(resolve, 1000));

                // Check undo state after deletion
                const undoCountAfter = testWindow.undoStore.undoCount;
                const nodesAfterDelete = testWindow.document.querySelectorAll('.vue-flow__node');

                log(`Undo count after deletion: ${undoCountAfter}`, 'info');
                log(`Nodes after deletion: ${nodesAfterDelete.length}`, 'info');

                if (undoCountAfter > undoCountBefore) {
                    log('‚úÖ SUCCESS: Undo count incremented!', 'success');
                    return { success: true, deleted: nodes.length - nodesAfterDelete.length };
                } else {
                    log('‚ùå FAILED: Undo count did not increment', 'error');
                    return { success: false, deleted: 0 };
                }
            } catch (error) {
                log(`Failed to delete task: ${error.message}`, 'error');
                return { success: false, deleted: 0 };
            }
        }

        async function testUndo() {
            log('Testing undo with Cmd+Z...', 'test');

            try {
                const undoCountBefore = testWindow.undoStore.undoCount;
                const nodesBefore = testWindow.document.querySelectorAll('.vue-flow__node').length;

                // Send Cmd+Z (or Ctrl+Z) event
                testWindow.document.dispatchEvent(new testWindow.KeyboardEvent('keydown', {
                    key: 'z',
                    metaKey: true, // Use metaKey for Mac-like behavior
                    bubbles: true,
                    cancelable: true
                }));

                await new Promise(resolve => setTimeout(resolve, 1000));

                const undoCountAfter = testWindow.undoStore.undoCount;
                const nodesAfter = testWindow.document.querySelectorAll('.vue-flow__node').length;

                log(`Nodes after undo: ${nodesAfter} (was ${nodesBefore})`, 'info');

                if (nodesAfter > nodesBefore) {
                    log('‚úÖ SUCCESS: Task restored with undo!', 'success');
                    return { success: true, restored: nodesAfter - nodesBefore };
                } else {
                    log('‚ùå FAILED: Task not restored with undo', 'error');
                    return { success: false, restored: 0 };
                }
            } catch (error) {
                log(`Failed to test undo: ${error.message}`, 'error');
                return { success: false, restored: 0 };
            }
        }

        async function runAutomatedTest() {
            updateStatus('running', 'Running Automated Test');
            log('üöÄ Starting comprehensive undo/redo test suite', 'test');

            try {
                // Step 1: Wait for canvas
                if (!await waitForCanvas()) {
                    throw new Error('Failed to access canvas');
                }
                currentTest = 1;
                updateTestProgress();

                // Step 2: Create test task
                if (!await createTestTask()) {
                    throw new Error('Failed to create test task');
                }
                currentTest = 2;
                updateTestProgress();

                // Step 3: Delete task and verify undo count
                const deleteResult = await selectAndDeleteTask();
                if (!deleteResult.success) {
                    throw new Error('Failed to delete task or undo count not incremented');
                }
                currentTest = 3;
                updateTestProgress();

                // Step 4: Test undo
                const undoResult = await testUndo();
                if (!undoResult.success) {
                    throw new Error('Failed to restore task with undo');
                }
                currentTest = 4;
                updateTestProgress();

                // Additional verification
                log('üéØ Performing additional verification...', 'test');
                updateMetrics();

                log('üéâ ALL TESTS PASSED! Undo/redo system is working correctly!', 'success');
                updateStatus('success', 'All Tests Passed');

                document.getElementById('startTest').disabled = true;

            } catch (error) {
                log(`‚ùå TEST FAILED: ${error.message}`, 'error');
                updateStatus('error', 'Test Failed');
            }
        }

        function updateTestProgress() {
            document.getElementById('testsCompleted').textContent = `${currentTest}/${tests.length}`;
        }

        function startAutomatedTest() {
            document.getElementById('startTest').disabled = true;
            runAutomatedTest();
        }

        function enableManualTest() {
            updateStatus('running', 'Manual Testing Enabled');
            document.getElementById('manualMode').className = 'status-indicator success';
            document.getElementById('manualModeText').textContent = 'Enabled';
            log('üéÆ Manual testing enabled. You can now use keyboard shortcuts in the canvas above.', 'info');
            log('Try: Select a task and press Delete, then Cmd+Z to undo.', 'info');

            // Update metrics periodically
            testInterval = setInterval(updateMetrics, 1000);
        }

        function resetTest() {
            currentTest = 0;
            testResults = [];
            updateTestProgress();
            updateStatus('pending', 'Ready');
            document.getElementById('manualMode').className = 'status-indicator pending';
            document.getElementById('manualModeText').textContent = 'Disabled';
            document.getElementById('startTest').disabled = false;
            document.getElementById('testLog').innerHTML = 'üìä Test log will appear here...';

            if (testInterval) {
                clearInterval(testInterval);
                testInterval = null;
            }

            // Reload iframe
            const frame = document.getElementById('canvasFrame');
            frame.src = frame.src;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            log('üß™ Comprehensive undo/redo test suite loaded', 'success');
            log('Ready to test canvas deletion functionality', 'info');
        });
    </script>
</body>
</html>