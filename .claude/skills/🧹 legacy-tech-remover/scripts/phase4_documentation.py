#!/usr/bin/env python3
"""
Phase 4: Documentation & Team Communication
Updates documentation, generates migration guides, and creates team communications
"""

import os
import sys
import json
import csv
from pathlib import Path
from typing import Dict, List, Set, Tuple, Any, Optional
from dataclasses import dataclass, asdict
from datetime import datetime
import yaml
import markdown
import re

@dataclass
class DocumentationUpdate:
    """Represents a documentation update"""
    file_path: str
    update_type: str  # 'remove_reference', 'update_guide', 'add_migration_note'
    old_content: str
    new_content: str
    reason: str
    priority: int  # 1-5, 5 being highest

@dataclass
class TeamCommunication:
    """Represents team communication item"""
    comm_type: str  # 'pr', 'announcement', 'migration_guide'
    title: str
    content: str
    recipients: List[str]
    priority: str  # 'high', 'medium', 'low'
    channels: List[str]  # ['slack', 'email', 'github', 'confluence']

class DocumentationManager:
    def __init__(self, execution_report_path: str, project_root: Path = None):
        self.project_root = project_root or Path.cwd()
        self.execution_report = self._load_execution_report(execution_report_path)
        self.config = self._load_config()
        self.doc_updates = []
        self.communications = []
        self.migration_log = []

        # Documentation patterns
        self.doc_patterns = {
            'readme': ['README.md', 'README.rst', 'README.txt'],
            'contributing': ['CONTRIBUTING.md', 'CONTRIBUTING.rst'],
            'api_docs': ['docs/api/', 'documentation/api/', 'API.md'],
            'architecture': ['docs/architecture/', 'ARCHITECTURE.md'],
            'setup': ['docs/setup/', 'INSTALL.md', 'SETUP.md'],
            'changelog': ['CHANGELOG.md', 'HISTORY.md'],
            'migration': ['docs/migration/', 'MIGRATION.md']
        }

        # Team communication templates
        self.communication_templates = self._load_communication_templates()

    def _load_config(self) -> Dict:
        """Load documentation configuration"""
        config_path = self.project_root / '.claude' / 'legacy-remover-config.yml'
        default_config = {
            'documentation': {
                'auto_update': True,
                'backup_docs': True,
                'update_readme': True,
                'update_api_docs': True,
                'create_migration_guide': True,
                'doc_paths': [
                    'docs/',
                    'documentation/',
                    'README.md',
                    'CONTRIBUTING.md'
                ]
            },
            'communication': {
                'auto_pr': True,
                'team_announcement': True,
                'channels': ['slack', 'github'],
                'notification_level': 'important_changes',
                'stakeholders': [
                    'dev-team@company.com',
                    'tech-lead@company.com',
                    'pm-team@company.com'
                ]
            },
            'migration': {
                'create_guide': True,
                'include_examples': True,
                'include_rollbacks': True,
                'timeline_days': 30
            }
        }

        if config_path.exists():
            try:
                with open(config_path, 'r') as f:
                    user_config = yaml.safe_load(f)
                    default_config.update(user_config)
            except Exception as e:
                print(f"Warning: Could not load config: {e}")

        return default_config

    def _load_execution_report(self, report_path: str) -> Dict:
        """Load execution report from Phase 3"""
        try:
            with open(report_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(f"Error loading execution report: {e}")
            return {}

    def _load_communication_templates(self) -> Dict:
        """Load communication templates"""
        return {
            'pr_template': '''
# Legacy Tech Removal - {date}

## Summary
{summary}

## Changes Made
{changes}

## Impact Assessment
- **Files Removed**: {files_removed}
- **Libraries Removed**: {libraries_removed}
- **Size Reduction**: {size_reduction}
- **Build Impact**: {build_impact}

## Testing
- [ ] All tests pass
- [ ] Build succeeds
- [ ] No breaking changes detected

## Rollback Information
{rollback_info}

## Migration Notes
{migration_notes}

## Review Checklist
- [ ] Code changes reviewed
- [ ] Documentation updated
- [ ] Tests pass
- [ ] Team notified

---

Generated by Legacy Tech Remover Skill
''',
            'announcement_template': '''
## üßπ Legacy Tech Removal Complete - {date}

### What Happened
We've successfully removed deprecated/legacy technology from our codebase to improve maintainability and reduce technical debt.

### Key Changes
{key_changes}

### Impact
- **Zero production incidents** ‚úÖ
- **Improved build performance** ‚ö°
- **Reduced bundle size** üì¶
- **Cleaner codebase** üßπ

### Migration Guide
{migration_summary}

### Questions?
See the detailed migration guide or contact the dev team.

---
*Generated by Claude Code - Legacy Tech Remover*
''',
            'migration_guide_template': '''
# Migration Guide - Legacy Removal {date}

## Overview
This guide documents the removal of legacy technology and provides migration instructions.

## Removed Components
{removed_components}

## Migration Steps
{migration_steps}

## Breaking Changes
{breaking_changes}

## Rollback Procedures
{rollback_procedures}

## Support
If you encounter issues:
1. Check this migration guide
2. Review the rollback procedures
3. Contact the development team

## Additional Resources
{additional_resources}
'''
        }

    def scan_documentation_for_references(self) -> List[DocumentationUpdate]:
        """Scan documentation for references to removed legacy items"""
        print("üîç Scanning documentation for legacy references...")

        doc_updates = []
        removed_items = self._extract_removed_items()

        if not removed_items:
            print("   No removed items found in execution report")
            return doc_updates

        # Find all documentation files
        doc_files = self._find_documentation_files()

        for doc_file in doc_files:
            try:
                updates = self._scan_document_file(doc_file, removed_items)
                doc_updates.extend(updates)
            except Exception as e:
                print(f"   Error scanning {doc_file}: {e}")

        print(f"   Found {len(doc_updates)} documentation references to update")
        self.doc_updates = doc_updates
        return doc_updates

    def _extract_removed_items(self) -> List[Dict]:
        """Extract list of removed items from execution report"""
        removed_items = []

        try:
            batches = self.execution_report.get('batches', [])
            for batch in batches:
                steps = batch.get('steps', [])
                for step in steps:
                    if step.get('status') == 'passed':
                        removed_items.append({
                            'path': step.get('item_path', ''),
                            'name': Path(step.get('item_path', '')).name,
                            'action_type': step.get('action_type', ''),
                            'command': step.get('command', '')
                        })
        except Exception as e:
            print(f"Error extracting removed items: {e}")

        return removed_items

    def _find_documentation_files(self) -> List[Path]:
        """Find all documentation files in the project"""
        doc_files = []

        # Add explicit doc paths
        for doc_path in self.config['documentation']['doc_paths']:
            path = self.project_root / doc_path
            if path.exists():
                if path.is_file() and path.suffix in ['.md', '.rst', '.txt']:
                    doc_files.append(path)
                elif path.is_dir():
                    doc_files.extend(path.rglob('*.md'))
                    doc_files.extend(path.rglob('*.rst'))
                    doc_files.extend(path.rglob('*.txt'))

        # Add common doc files
        common_docs = ['README.md', 'CONTRIBUTING.md', 'CHANGELOG.md', 'INSTALL.md']
        for doc in common_docs:
            doc_path = self.project_root / doc
            if doc_path.exists():
                doc_files.append(doc_path)

        return list(set(doc_files))  # Remove duplicates

    def _scan_document_file(self, doc_file: Path, removed_items: List[Dict]) -> List[DocumentationUpdate]:
        """Scan a single documentation file for legacy references"""
        updates = []

        try:
            with open(doc_file, 'r', encoding='utf-8') as f:
                content = f.read()

            for item in removed_items:
                item_name = item['name']
                item_path = item['path']

                # Check for various reference patterns
                reference_patterns = [
                    item_name,
                    item_path,
                    item_path.replace('\\', '/'),
                    Path(item_path).stem,
                    item_name.split('.')[0]  # Without extension
                ]

                for pattern in reference_patterns:
                    if pattern.lower() in content.lower():
                        # Create documentation update
                        update = self._create_documentation_update(
                            doc_file, content, item, pattern
                        )
                        updates.append(update)
                        break  # Only create one update per item per file

        except Exception as e:
            print(f"   Error reading {doc_file}: {e}")

        return updates

    def _create_documentation_update(self, doc_file: Path, content: str, item: Dict, pattern: str) -> DocumentationUpdate:
        """Create a documentation update object"""
        file_path_str = str(doc_file.relative_to(self.project_root))

        # Determine update type based on context
        if 'install' in content.lower() or 'setup' in content.lower():
            update_type = 'update_guide'
            priority = 4
        elif 'api' in content.lower() or 'reference' in content.lower():
            update_type = 'update_api_docs'
            priority = 3
        elif 'example' in content.lower():
            update_type = 'update_examples'
            priority = 2
        else:
            update_type = 'remove_reference'
            priority = 3

        # Generate new content
        new_content = self._generate_updated_content(content, item, pattern)

        reason = f"Remove reference to {item['name']} ({item['action_type']})"

        return DocumentationUpdate(
            file_path=file_path_str,
            update_type=update_type,
            old_content=content,
            new_content=new_content,
            reason=reason,
            priority=priority
        )

    def _generate_updated_content(self, content: str, item: Dict, pattern: str) -> str:
        """Generate updated content with legacy references removed"""
        new_content = content

        # Remove or update references
        item_name = item['name']
        item_path = item['path']

        # Common patterns to replace
        replacements = [
            # Code blocks
            (rf'```.*?{re.escape(pattern)}.*?```', '```\n# Legacy code removed\n```'),
            # Inline code
            (rf'`{re.escape(pattern)}`', '`[legacy code removed]`'),
            # Install commands
            (rf'npm install.*{re.escape(item_name)}', f'# npm install {item_name} (removed)'),
            # Import statements
            (rf'import.*{re.escape(item_name)}', f'# import {item_name} (removed)'),
            # General references
            (rf'{re.escape(pattern)}', f'~~{pattern}~~ (removed)')
        ]

        for pattern_to_find, replacement in replacements:
            new_content = re.sub(pattern_to_find, replacement, new_content, flags=re.IGNORECASE | re.DOTALL)

        # Add migration note if appropriate
        if item['action_type'] in ['REVIEW_REQUIRED', 'MIGRATION_REQUIRED']:
            migration_note = f"\n\n> **Note**: `{item_name}` has been removed. See migration guide for alternatives."
            if not migration_note in new_content:
                new_content += migration_note

        return new_content

    def update_documentation(self, dry_run: bool = False) -> List[DocumentationUpdate]:
        """Update documentation files"""
        print("üìù Updating documentation files...")

        if not self.doc_updates:
            self.scan_documentation_for_references()

        if not self.doc_updates:
            print("   No documentation updates needed")
            return []

        # Sort by priority (highest first)
        sorted_updates = sorted(self.doc_updates, key=lambda x: x.priority, reverse=True)

        updated_files = []

        for update in sorted_updates:
            try:
                doc_file = self.project_root / update.file_path

                if not doc_file.exists():
                    print(f"   ‚ö†Ô∏è Documentation file not found: {update.file_path}")
                    continue

                # Backup original file
                if self.config['documentation']['backup_docs']:
                    backup_file = doc_file.with_suffix(f'{doc_file.suffix}.backup')
                    doc_file.rename(backup_file)
                    print(f"   üìã Backed up: {backup_file.name}")

                if not dry_run:
                    # Write updated content
                    with open(doc_file, 'w', encoding='utf-8') as f:
                        f.write(update.new_content)
                    updated_files.append(update)
                    print(f"   ‚úÖ Updated: {update.file_path} ({update.update_type})")
                else:
                    print(f"   üîç Would update: {update.file_path} ({update.update_type})")

            except Exception as e:
                print(f"   ‚ùå Error updating {update.file_path}: {e}")

        print(f"   Documentation updates: {len(updated_files)} files")
        return updated_files

    def create_migration_guide(self) -> str:
        """Create comprehensive migration guide"""
        print("üìö Creating migration guide...")

        removed_items = self._extract_removed_items()
        migration_steps = self._generate_migration_steps(removed_items)

        # Build migration guide content
        guide_content = self.communication_templates['migration_guide_template'].format(
            date=datetime.now().strftime('%Y-%m-%d'),
            removed_components=self._format_removed_components(removed_items),
            migration_steps=self._format_migration_steps(migration_steps),
            breaking_changes=self._identify_breaking_changes(removed_items),
            rollback_procedures=self._generate_rollback_procedures(removed_items),
            additional_resources=self._generate_additional_resources()
        )

        # Save migration guide
        migration_guide_path = self.project_root / 'MIGRATION_GUIDE.md'
        try:
            with open(migration_guide_path, 'w', encoding='utf-8') as f:
                f.write(guide_content)
            print(f"   ‚úÖ Migration guide saved: {migration_guide_path}")
        except Exception as e:
            print(f"   ‚ùå Error saving migration guide: {e}")

        self.migration_log.append({
            'type': 'migration_guide',
            'file': str(migration_guide_path),
            'date': datetime.now().isoformat(),
            'items_count': len(removed_items)
        })

        return guide_content

    def _generate_migration_steps(self, removed_items: List[Dict]) -> List[Dict]:
        """Generate migration steps for removed items"""
        migration_steps = []

        for item in removed_items:
            if item['action_type'] in ['MIGRATION_REQUIRED', 'REVIEW_REQUIRED']:
                step = {
                    'item': item['name'],
                    'type': item['action_type'],
                    'recommended_action': self._get_recommended_migration_action(item),
                    'modern_alternatives': self._get_modern_alternatives(item),
                    'complexity': self._assess_migration_complexity(item)
                }
                migration_steps.append(step)

        return migration_steps

    def _get_recommended_migration_action(self, item: Dict) -> str:
        """Get recommended migration action for an item"""
        item_name = item['name'].lower()

        # Known migration patterns
        migrations = {
            'request': 'Replace with fetch() or axios',
            'moment': 'Replace with date-fns or luxon',
            'lodash': 'Use native JavaScript methods or modern alternatives',
            'bluebird': 'Use native Promise',
            'webpack': 'Use Vite or modern bundlers',
            'gulp': 'Use npm scripts or modern build tools',
            'grunt': 'Use npm scripts or modern build tools',
            'babel-preset-es2015': 'Use @babel/preset-env'
        }

        for key, migration in migrations.items():
            if key in item_name:
                return migration

        return "Evaluate modern alternatives based on functionality"

    def _get_modern_alternatives(self, item: Dict) -> List[str]:
        """Get modern alternatives for a legacy item"""
        item_name = item['name'].lower()

        alternatives_map = {
            'request': ['fetch', 'axios', 'got'],
            'moment': ['date-fns', 'dayjs', 'luxon'],
            'lodash': ['native JavaScript', 'ramda', 'remeda'],
            'jquery': ['native DOM API', 'vanilla JS'],
            'bluebird': ['native Promise', 'async/await'],
            'webpack': ['vite', 'rollup', 'esbuild'],
            'gulp': ['npm scripts', 'vite plugins', 'rollup plugins'],
            'grunt': ['npm scripts', 'vite', 'modern build tools']
        }

        for key, alternatives in alternatives_map.items():
            if key in item_name:
                return alternatives

        return ['Evaluate based on requirements']

    def _assess_migration_complexity(self, item: Dict) -> str:
        """Assess migration complexity for an item"""
        item_name = item['name'].lower()

        high_complexity = ['webpack', 'babel', 'build-system']
        medium_complexity = ['moment', 'lodash', 'request']
        low_complexity = ['bluebird', 'simple-libraries']

        for key in high_complexity:
            if key in item_name:
                return 'HIGH - System-wide changes required'

        for key in medium_complexity:
            if key in item_name:
                return 'MEDIUM - Multiple file updates required'

        for key in low_complexity:
            if key in item_name:
                return 'LOW - Simple replacement possible'

        return 'UNKNOWN - Assessment required'

    def _format_removed_components(self, removed_items: List[Dict]) -> str:
        """Format removed components for migration guide"""
        if not removed_items:
            return "No components removed."

        formatted = []
        for item in removed_items:
            formatted.append(f"- **{item['name']}** ({item['action_type']})")

        return '\n'.join(formatted)

    def _format_migration_steps(self, migration_steps: List[Dict]) -> str:
        """Format migration steps for migration guide"""
        if not migration_steps:
            return "No migration steps required."

        formatted = []
        for i, step in enumerate(migration_steps, 1):
            formatted.append(f"### {i}. {step['item']}")
            formatted.append(f"**Action**: {step['recommended_action']}")
            formatted.append(f"**Alternatives**: {', '.join(step['modern_alternatives'])}")
            formatted.append(f"**Complexity**: {step['complexity']}")
            formatted.append("")

        return '\n'.join(formatted)

    def _identify_breaking_changes(self, removed_items: List[Dict]) -> str:
        """Identify breaking changes from removed items"""
        breaking_changes = []

        for item in removed_items:
            if item['action_type'] in ['REVIEW_REQUIRED', 'MIGRATION_REQUIRED']:
                breaking_changes.append(f"- Removal of `{item['name']}` may require code updates")

        return '\n'.join(breaking_changes) if breaking_changes else "No breaking changes identified."

    def _generate_rollback_procedures(self, removed_items: List[Dict]) -> str:
        """Generate rollback procedures"""
        procedures = [
            "### Git Rollback",
            "```bash",
            "# View recent commits",
            "git log --oneline -10",
            "",
            "# Rollback specific commit",
            "git revert <commit-hash>",
            "",
            "# Rollback to specific commit",
            "git reset --hard <commit-hash>",
            "```",
            "",
            "### Package Rollback",
            "```bash",
            "# Reinstall removed packages",
            "npm install <package-name>",
            "",
            "# Restore from package-lock.json",
            "git checkout HEAD~1 -- package-lock.json",
            "npm install",
            "```"
        ]

        return '\n'.join(procedures)

    def _generate_additional_resources(self) -> str:
        """Generate additional resources section"""
        resources = [
            "- [Vue 3 Migration Guide](https://v3-migration.vuejs.org/)",
            "- [Node.js Best Practices](https://github.com/goldbergyoni/nodebestpractices)",
            "- [JavaScript Modern Features](https://developer.mozilla.org/en-US/docs/Web/JavaScript)",
            "- [Build Tool Comparison](https://2022.stateofjs.com/en-US/libraries/build-tools/)"
        ]

        return '\n'.join(resources)

    def create_pull_request(self) -> TeamCommunication:
        """Create pull request communication"""
        print("üîÄ Creating pull request...")

        # Extract summary information
        successful_items = self._count_successful_items()
        total_size_reduction = self._calculate_size_reduction()

        pr_content = self.communication_templates['pr_template'].format(
            date=datetime.now().strftime('%Y-%m-%d'),
            summary=self._generate_summary(),
            changes=self._format_changes(),
            files_removed=successful_items['files'],
            libraries_removed=successful_items['libraries'],
            size_reduction=f"{total_size_reduction}KB",
            build_impact="Build times improved" if successful_items['libraries'] > 0 else "No build impact",
            rollback_info=self._generate_rollback_info(),
            migration_notes="See MIGRATION_GUIDE.md for detailed migration information"
        )

        pr_comm = TeamCommunication(
            comm_type='pr',
            title=f"üßπ Legacy Tech Removal - {datetime.now().strftime('%Y-%m-%d')}",
            content=pr_content,
            recipients=['dev-team'],
            priority='medium',
            channels=['github']
        )

        self.communications.append(pr_comm)
        return pr_comm

    def create_team_announcement(self) -> TeamCommunication:
        """Create team announcement communication"""
        print("üì¢ Creating team announcement...")

        successful_items = self._count_successful_items()

        announcement_content = self.communication_templates['announcement_template'].format(
            date=datetime.now().strftime('%Y-%m-%d'),
            key_changes=self._format_key_changes(successful_items),
            migration_summary="See MIGRATION_GUIDE.md for detailed migration steps"
        )

        announcement = TeamCommunication(
            comm_type='announcement',
            title=f"üßπ Legacy Tech Removal Complete",
            content=announcement_content,
            recipients=['all-team'],
            priority='medium',
            channels=self.config['communication']['channels']
        )

        self.communications.append(announcement)
        return announcement

    def _count_successful_items(self) -> Dict[str, int]:
        """Count successful removals by type"""
        successful_items = {'files': 0, 'libraries': 0, 'configs': 0, 'total': 0}

        try:
            batches = self.execution_report.get('batches', [])
            for batch in batches:
                steps = batch.get('steps', [])
                for step in steps:
                    if step.get('status') == 'passed':
                        successful_items['total'] += 1
                        command = step.get('command', '').lower()
                        item_path = step.get('item_path', '')

                        if 'npm uninstall' in command or 'pip uninstall' in command:
                            successful_items['libraries'] += 1
                        elif item_path.endswith(('.json', '.yml', '.yaml', '.js')):
                            successful_items['configs'] += 1
                        else:
                            successful_items['files'] += 1
        except Exception as e:
            print(f"Error counting successful items: {e}")

        return successful_items

    def _calculate_size_reduction(self) -> int:
        """Calculate total size reduction"""
        total_size = 0

        try:
            batches = self.execution_report.get('batches', [])
            for batch in batches:
                steps = batch.get('steps', [])
                for step in steps:
                    if step.get('status') == 'passed':
                        # In a real implementation, this would use actual file sizes
                        total_size += 50  # Placeholder size
        except Exception as e:
            print(f"Error calculating size reduction: {e}")

        return total_size

    def _generate_summary(self) -> str:
        """Generate execution summary"""
        successful_items = self._count_successful_items()
        return (
            f"Successfully removed {successful_items['total']} legacy items: "
            f"{successful_items['libraries']} libraries, {successful_items['files']} files, "
            f"{successful_items['configs']} configuration files."
        )

    def _format_changes(self) -> str:
        """Format changes for PR description"""
        changes = []

        try:
            batches = self.execution_report.get('batches', [])
            for batch in batches:
                steps = batch.get('steps', [])
                for step in steps:
                    if step.get('status') == 'passed':
                        command = step.get('command', '')
                        if command:
                            changes.append(f"- `{command}`")
        except Exception as e:
            print(f"Error formatting changes: {e}")

        return '\n'.join(changes) if changes else "No changes recorded."

    def _generate_rollback_info(self) -> str:
        """Generate rollback information"""
        return (
            "All changes have been committed with `[legacy-removal]` prefix. "
            "Use `git revert <commit-hash>` to rollback specific changes, "
            "or `git log --grep='legacy-removal'` to view all removal commits."
        )

    def _format_key_changes(self, successful_items: Dict[str, int]) -> str:
        """Format key changes for announcement"""
        changes = [
            f"‚Ä¢ **{successful_items['libraries']}** deprecated libraries removed",
            f"‚Ä¢ **{successful_items['files']}** obsolete files deleted",
            f"‚Ä¢ **{successful_items['configs']}** legacy configurations cleaned up"
        ]

        return '\n'.join(changes)

    def generate_documentation_reports(self, output_dir: Path) -> Dict[str, str]:
        """Generate all documentation reports"""
        print("üìä Generating documentation reports...")

        reports = {}

        # Documentation update report
        doc_update_report = {
            'generation_date': datetime.now().isoformat(),
            'total_updates': len(self.doc_updates),
            'updates_by_type': {},
            'high_priority_updates': len([u for u in self.doc_updates if u.priority >= 4])
        }

        for update in self.doc_updates:
            update_type = update.update_type
            doc_update_report['updates_by_type'][update_type] = doc_update_report['updates_by_type'].get(update_type, 0) + 1

        reports['documentation_updates'] = json.dumps(doc_update_report, indent=2)

        # Communication report
        comm_report = {
            'generation_date': datetime.now().isoformat(),
            'total_communications': len(self.communications),
            'communications_by_type': {}
        }

        for comm in self.communications:
            comm_type = comm.comm_type
            comm_report['communications_by_type'][comm_type] = comm_report['communications_by_type'].get(comm_type, 0) + 1

        reports['communications'] = json.dumps(comm_report, indent=2)

        # Migration log
        migration_report = {
            'generation_date': datetime.now().isoformat(),
            'migration_log': self.migration_log
        }

        reports['migration_log'] = json.dumps(migration_report, indent=2)

        # Save reports to files
        for report_name, report_content in reports.items():
            report_path = output_dir / f'{report_name}.json'
            try:
                with open(report_path, 'w', encoding='utf-8') as f:
                    f.write(report_content)
                print(f"   ‚úÖ Report saved: {report_path}")
            except Exception as e:
                print(f"   ‚ùå Error saving {report_name}: {e}")

        return reports

    def run_full_documentation_process(self, dry_run: bool = False) -> Dict[str, Any]:
        """Run complete documentation and communication process"""
        print("üöÄ Starting full documentation and communication process...")

        results = {
            'doc_updates': [],
            'communications': [],
            'migration_guide': '',
            'reports': {}
        }

        # Update documentation
        if self.config['documentation']['auto_update']:
            results['doc_updates'] = self.update_documentation(dry_run)

        # Create migration guide
        if self.config['migration']['create_guide']:
            results['migration_guide'] = self.create_migration_guide()

        # Create communications
        if self.config['communication']['auto_pr']:
            results['communications'].append(self.create_pull_request())

        if self.config['communication']['team_announcement']:
            results['communications'].append(self.create_team_announcement())

        # Generate reports
        output_dir = self.project_root / 'legacy-removal-reports'
        output_dir.mkdir(exist_ok=True)
        results['reports'] = self.generate_documentation_reports(output_dir)

        print("‚úÖ Documentation and communication process completed")
        return results

def main():
    import argparse

    parser = argparse.ArgumentParser(description="Update documentation and create team communications")
    parser.add_argument('execution_report', help='Path to execution report JSON from Phase 3')
    parser.add_argument('--output-dir', default='.', help='Output directory for reports')
    parser.add_argument('--project-root', help='Project root directory')
    parser.add_argument('--dry-run', action='store_true', help='Preview changes without applying')
    parser.add_argument('--skip-docs', action='store_true', help='Skip documentation updates')
    parser.add_argument('--skip-communications', action='store_true', help='Skip team communications')

    args = parser.parse_args()

    project_root = Path(args.project_root) if args.project_root else Path.cwd()
    output_dir = Path(args.output_dir)

    # Initialize documentation manager
    doc_manager = DocumentationManager(args.execution_report, project_root)

    # Configure based on flags
    if args.skip_docs:
        doc_manager.config['documentation']['auto_update'] = False
    if args.skip_communications:
        doc_manager.config['communication']['auto_pr'] = False
        doc_manager.config['communication']['team_announcement'] = False

    # Run process
    results = doc_manager.run_full_documentation_process(args.dry_run)

    # Print summary
    print(f"\nüìä Documentation Summary:")
    print(f"   Documentation updates: {len(results['doc_updates'])}")
    print(f"   Team communications: {len(results['communications'])}")
    print(f"   Migration guide: {'Created' if results['migration_guide'] else 'Skipped'}")
    print(f"   Reports saved to: {output_dir}")

    if args.dry_run:
        print(f"\nüîç DRY RUN completed - no actual changes made")
        print(f"   Run without '--dry-run' to apply changes")

if __name__ == '__main__':
    main()