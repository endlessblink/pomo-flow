/**
 * Update the router with all discovered skills
 */

const fs = require('fs');
const path = require('path');

async function updateRouter() {
  console.log('ðŸ”„ Updating Skill Router with Latest Skills\n');

  const skillsPath = path.join(__dirname, '..');
  const configPath = path.join(__dirname, 'routing-config.json');

  // Create backup first
  const backupPath = path.join(__dirname, 'backups', `routing-config-backup-${Date.now()}.json`);
  const backupDir = path.dirname(backupPath);
  if (!fs.existsSync(backupDir)) {
    fs.mkdirSync(backupDir, { recursive: true });
  }

  if (fs.existsSync(configPath)) {
    fs.copyFileSync(configPath, backupPath);
    console.log(`ðŸ“‹ Backup created: ${path.basename(backupPath)}`);
  }

  // Load current config
  let config;
  try {
    const configData = fs.readFileSync(configPath, 'utf-8');
    config = JSON.parse(configData);
    console.log(`ðŸ“‹ Loaded current config with ${Object.keys(config.routingPatterns || {}).length} patterns`);
  } catch (error) {
    console.log('âš ï¸ No valid config found, creating new one');
    config = {
      version: "1.0.0",
      project: "pomo-flow",
      description: "Intelligent skill routing configuration for Pomo-Flow productivity application",
      routingPatterns: {},
      mandatoryGates: {
        beforeSuccessClaim: {
          triggers: ["claim.*works", "claim.*done", "ready.*production"],
          requiredSkills: ["qa-testing", "qa-verify"],
          description: "Mandatory testing and verification before claiming success"
        },
        beforeDeployment: {
          triggers: ["deploy.*", "merge.*", "release.*"],
          requiredSkills: ["qa-testing", "qa-verify"],
          description: "Mandatory testing and verification before deployment"
        }
      },
      contextualRouting: {
        fileBased: {
          "*.vue": { defaultSkill: "dev-vue", additionalContext: ["component", "template"] },
          "*/stores/*.ts": { defaultSkill: "dev-pinia-state", additionalContext: ["state", "store"] },
          "*/canvas/*": { defaultSkill: "calendar-canvas-integration", additionalContext: ["canvas", "drag"] }
        }
      }
    };
  }

  // Discover all skills
  const skills = fs.readdirSync(skillsPath, { withFileTypes: true })
    .filter(item => item.isDirectory() && item.name !== 'skill-router')
    .map(item => item.name);

  console.log(`ðŸ” Found ${skills.length} skill directories`);

  let addedCount = 0;
  let skippedCount = 0;

  for (const skillFolder of skills) {
    const skillMdPath = path.join(skillsPath, skillFolder, 'SKILL.md');

    if (!fs.existsSync(skillMdPath)) {
      console.log(`âš ï¸ Skipping ${skillFolder} (no SKILL.md)`);
      skippedCount++;
      continue;
    }

    try {
      const content = fs.readFileSync(skillMdPath, 'utf-8');
      const stats = fs.statSync(skillMdPath);

      // Parse frontmatter
      const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
      let name = skillFolder;
      let description = '';
      let keywords = [];
      let priority = 5;

      if (frontmatterMatch) {
        const frontmatter = frontmatterMatch[1];

        const nameMatch = frontmatter.match(/name:\s*(.+)/);
        if (nameMatch) name = nameMatch[1].trim();

        const descMatch = frontmatter.match(/description:\s*(.+)/);
        if (descMatch) description = descMatch[1].trim();

        const keywordsMatch = frontmatter.match(/keywords:\s*\[(.+)\]/);
        if (keywordsMatch) {
          keywords = keywordsMatch[1].split(',').map(k => k.trim().replace(/['"]/g, ''));
        }

        const priorityMatch = frontmatter.match(/priority:\s*(\d+)/);
        if (priorityMatch) priority = parseInt(priorityMatch[1]);
      }

      // Generate patterns
      const patterns = generatePatterns(name, description, keywords);

      // Determine category and suggested priority
      const category = inferCategory(name, description);
      const suggestedPriority = suggestPriority(name, category, priority);

      // Create routing pattern
      const routingPattern = {
        patterns: patterns.slice(0, 5), // Top 5 patterns
        skill: name,
        priority: suggestedPriority,
        description: description,
        category: category,
        autoGenerated: true,
        generatedAt: new Date().toISOString()
      };

      // Check if already exists
      const existingKey = Object.keys(config.routingPatterns).find(key =>
        config.routingPatterns[key].skill === name
      );

      if (existingKey) {
        console.log(`ðŸ”„ Updating existing skill: ${name}`);
        config.routingPatterns[existingKey] = routingPattern;
      } else {
        console.log(`âž• Adding new skill: ${name} (${category})`);
        config.routingPatterns[skillFolder] = routingPattern;
        addedCount++;
      }

    } catch (error) {
      console.log(`âŒ Error processing ${skillFolder}: ${error.message}`);
      skippedCount++;
    }
  }

  // Save updated config
  try {
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    console.log(`\nâœ… Router configuration updated successfully!`);
    console.log(`ðŸ“Š Summary: ${addedCount} added, ${skippedCount} skipped`);
    console.log(`ðŸ“‹ Total skills in router: ${Object.keys(config.routingPatterns).length}`);

    // Test a few patterns
    console.log('\nðŸ§ª Testing pattern matching:');
    const testCases = [
      'fix the timer bug',
      'test the new feature',
      'audit ui consistency',
      'optimize performance'
    ];

    testCases.forEach(input => {
      let matched = false;
      let matchedSkill = '';

      Object.entries(config.routingPatterns).forEach(([key, pattern]) => {
        pattern.patterns.forEach(regexPattern => {
          try {
            const regex = new RegExp(regexPattern, 'i');
            if (regex.test(input)) {
              matched = true;
              matchedSkill = pattern.skill;
            }
          } catch (error) {
            // Skip invalid patterns
          }
        });
      });

      console.log(`   "${input}" â†’ ${matched ? `âœ… ${matchedSkill}` : 'âŒ No match'}`);
    });

  } catch (error) {
    console.error('âŒ Failed to save config:', error.message);

    // Restore backup
    if (fs.existsSync(backupPath)) {
      fs.copyFileSync(backupPath, configPath);
      console.log('ðŸ”„ Restored backup due to error');
    }
  }
}

function generatePatterns(name, description, keywords) {
  const patterns = [];

  // From name
  const normalized = name.toLowerCase().replace(/[^a-z0-9\s]/g, ' ').trim();
  const words = normalized.split(/\s+/).filter(w => w.length > 2);

  if (words.length > 0) {
    patterns.push(`${normalized.replace(/\s+/g, '.*')}.*`);
    words.forEach(word => patterns.push(`${word}.*`));

    if (words.length >= 2) {
      for (let i = 0; i < words.length - 1; i++) {
        patterns.push(`${words[i]}.*${words[i + 1]}.*`);
      }
    }
  }

  // From description
  const actionWords = ['create', 'build', 'fix', 'debug', 'test', 'optimize', 'implement', 'add'];
  const normalizedDesc = description.toLowerCase();

  actionWords.forEach(action => {
    if (normalizedDesc.includes(action)) {
      patterns.push(`${action}.*`);
    }
  });

  // From keywords
  keywords.forEach(keyword => {
    patterns.push(`${keyword.toLowerCase()}.*`);
  });

  return patterns.slice(0, 10);
}

function inferCategory(name, description) {
  const combined = `${name} ${description}`.toLowerCase();

  const categories = {
    'testing': ['test', 'testing', 'verify', 'validation', 'check'],
    'debugging': ['debug', 'fix', 'bug', 'error', 'issue', 'problem'],
    'development': ['create', 'build', 'implement', 'add', 'develop', 'component'],
    'performance': ['performance', 'optimize', 'speed', 'slow', 'fast'],
    'ui': ['ui', 'ux', 'interface', 'design', 'style', 'theme', 'visual'],
    'state': ['state', 'store', 'data', 'persist', 'save', 'database']
  };

  let bestCategory = 'development';
  let bestScore = 0;

  for (const [category, keywords] of Object.entries(categories)) {
    const score = keywords.reduce((acc, keyword) => {
      return acc + (combined.includes(keyword) ? 1 : 0);
    }, 0);

    if (score > bestScore) {
      bestScore = score;
      bestCategory = category;
    }
  }

  return bestCategory;
}

function suggestPriority(name, category, explicitPriority) {
  if (explicitPriority && explicitPriority !== 5) return explicitPriority;

  const categoryPriorities = {
    'testing': 10,
    'debugging': 9,
    'performance': 8,
    'development': 7,
    'state': 6,
    'ui': 5
  };

  return categoryPriorities[category] || 5;
}

// Run the update
updateRouter();